import "./chunk-VKZUKYIM.js";
import {
  computed,
  reactive,
  ref,
  toRef
} from "./chunk-BJMSG4PK.js";
import "./chunk-AUZ3RYOM.js";

// node_modules/vue-timer-hook/dist/vue-timer-hook.esm-bundler.js
var Time = class _Time {
  static getTimeFromSeconds(secs) {
    const totalSeconds = computed(() => Math.ceil(secs.value));
    const days = computed(() => Math.floor(totalSeconds.value / (60 * 60 * 24)));
    const hours = computed(() => Math.floor(totalSeconds.value % (60 * 60 * 24) / (60 * 60)));
    const minutes = computed(() => Math.floor(totalSeconds.value % (60 * 60) / 60));
    const seconds = computed(() => Math.floor(totalSeconds.value % 60));
    return {
      seconds,
      minutes,
      hours,
      days
    };
  }
  static getSecondsFromExpiry(expiry, shouldRound) {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const milliSecondsDistance = expiry - now;
    if (milliSecondsDistance > 0) {
      const val = milliSecondsDistance / 1e3;
      return shouldRound ? Math.round(val) : val;
    }
    return 0;
  }
  static getSecondsFromPrevTime(prevTime, shouldRound) {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const milliSecondsDistance = now - prevTime;
    if (milliSecondsDistance > 0) {
      const val = milliSecondsDistance / 1e3;
      return shouldRound ? Math.round(val) : val;
    }
    return 0;
  }
  static getSecondsFromTimeNow() {
    const now = /* @__PURE__ */ new Date();
    const currentTimestamp = now.getTime();
    const offset = now.getTimezoneOffset() * 60;
    return currentTimestamp / 1e3 - offset;
  }
  static getFormattedTimeFromSeconds(totalSeconds, format) {
    const { seconds: secondsValue, minutes, hours } = _Time.getTimeFromSeconds(totalSeconds);
    const ampm = computed(() => format === "12-hour" ? hours.value >= 12 ? "pm" : "am" : "");
    const hoursValue = computed(() => format === "12-hour" ? hours.value % 12 : hours.value);
    return {
      seconds: secondsValue,
      minutes,
      hours: hoursValue,
      ampm
    };
  }
};
var Validate = class {
  static expiryTimestamp(expiryTimestamp) {
    const isValid = new Date(expiryTimestamp).getTime() > 0;
    if (!isValid) {
      console.warn("vue-timer-hook: { useTimer } Invalid expiryTimestamp settings", expiryTimestamp);
    }
    return isValid;
  }
};
var isNumber = (val) => typeof val === "number";
function useInterval(callback, ms) {
  let intervalId = void 0;
  const remove = () => {
    if (!intervalId)
      return;
    clearInterval(intervalId);
    intervalId = void 0;
  };
  const start = (_ms) => {
    remove();
    if (!_ms && !ms) {
      return;
    }
    const m = _ms || ms;
    return intervalId = setInterval(callback, m);
  };
  if (isNumber(ms)) {
    start();
  }
  return { remove, start };
}
var DEFAULT_DELAY = 1e3;
function getDelayFromExpiryTimestamp(expiryTimestamp) {
  if (!Validate.expiryTimestamp(expiryTimestamp)) {
    return null;
  }
  const seconds = Time.getSecondsFromExpiry(expiryTimestamp);
  const extraMilliSeconds = Math.floor((seconds - Math.floor(seconds)) * 1e3);
  return extraMilliSeconds > 0 ? extraMilliSeconds : DEFAULT_DELAY;
}
var useTimer = (expiry = 60, autoStart = true) => {
  let interval;
  const state = reactive({
    expiryTimestamp: expiry,
    seconds: Time.getSecondsFromExpiry(expiry),
    isRunning: autoStart,
    isExpired: false,
    didStart: autoStart,
    delay: getDelayFromExpiryTimestamp(expiry)
  });
  function _handleExpire() {
    state.isExpired = true;
    state.isRunning = false;
    state.delay = null;
    if (interval)
      interval.remove();
  }
  function pause() {
    state.isRunning = false;
    if (interval)
      interval.remove();
  }
  function restart(newExpiryTimestamp = expiry, newAutoStart = true) {
    pause();
    state.delay = getDelayFromExpiryTimestamp(newExpiryTimestamp);
    state.didStart = newAutoStart;
    state.isExpired = false;
    state.expiryTimestamp = newExpiryTimestamp;
    state.seconds = Time.getSecondsFromExpiry(newExpiryTimestamp);
    if (state.didStart)
      start();
  }
  function resume() {
    const time = /* @__PURE__ */ new Date();
    const newExpiryTimestamp = time.setMilliseconds(time.getMilliseconds() + state.seconds * 1e3);
    restart(newExpiryTimestamp);
  }
  function start() {
    if (state.didStart) {
      state.seconds = Time.getSecondsFromExpiry(state.expiryTimestamp);
      state.isRunning = true;
      interval = useInterval(() => {
        if (state.delay !== DEFAULT_DELAY) {
          state.delay = DEFAULT_DELAY;
        }
        const secondsValue = Time.getSecondsFromExpiry(state.expiryTimestamp);
        state.seconds = secondsValue;
        if (secondsValue <= 0) {
          _handleExpire();
        }
      }, state.isRunning ? state.delay : null);
    } else {
      resume();
    }
  }
  restart(expiry, autoStart);
  return {
    ...Time.getTimeFromSeconds(toRef(state, "seconds")),
    start,
    pause,
    resume,
    restart,
    isRunning: toRef(state, "isRunning"),
    isExpired: toRef(state, "isExpired")
  };
};
var epochSeconds = () => (/* @__PURE__ */ new Date()).getTime();
var useStopwatch = (offsetTimestamp = 60, autoStart = true) => {
  let interval;
  const passedSeconds = ref(offsetTimestamp);
  const prevTime = ref(epochSeconds());
  const seconds = ref(passedSeconds.value + Time.getSecondsFromPrevTime(prevTime.value || 0, true));
  const isRunning = ref(autoStart);
  function start() {
    prevTime.value = epochSeconds();
    isRunning.value = true;
    seconds.value = passedSeconds.value + Time.getSecondsFromPrevTime(prevTime.value, true);
    interval = useInterval(() => {
      seconds.value = passedSeconds.value + Time.getSecondsFromPrevTime(prevTime.value, true);
    }, isRunning.value ? 1e3 : false);
  }
  function pause() {
    passedSeconds.value = seconds.value;
    isRunning.value = false;
    if (interval)
      interval.remove();
  }
  function reset(offset = 0, newAutoStart = true) {
    pause();
    isRunning.value = newAutoStart;
    passedSeconds.value = offset;
    seconds.value = +passedSeconds.value;
    Time.getSecondsFromPrevTime(prevTime.value, true);
    if (isRunning.value)
      start();
  }
  if (isRunning.value)
    start();
  return {
    ...Time.getTimeFromSeconds(seconds),
    start,
    pause,
    reset,
    isRunning
  };
};
var useTime = (format = "24-hour") => {
  const seconds = ref(Time.getSecondsFromTimeNow());
  useInterval(() => {
    seconds.value = Time.getSecondsFromTimeNow();
  }, 1e3);
  return {
    ...Time.getFormattedTimeFromSeconds(seconds, format)
  };
};
export {
  useStopwatch,
  useTime,
  useTimer
};
/*! Bundled license information:

vue-timer-hook/dist/vue-timer-hook.esm-bundler.js:
  (*!
    * vue-timer-hook v1.0.84
    * (c) 2023 Eduardo San Martin Morote
    * @license MIT
    *)
*/
//# sourceMappingURL=vue-timer-hook.js.map
