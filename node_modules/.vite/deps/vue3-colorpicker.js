import {
  merge_default
} from "./chunk-ZGZEN27C.js";
import "./chunk-VKZUKYIM.js";
import {
  Fragment,
  Teleport,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  inject,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onScopeDispose,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  unref,
  vShow,
  watch,
  withCtx,
  withDirectives
} from "./chunk-BJMSG4PK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/gradient-parser/build/node.js
var require_node = __commonJS({
  "node_modules/gradient-parser/build/node.js"(exports) {
    var GradientParser = GradientParser || {};
    GradientParser.stringify = function() {
      var visitor = {
        "visit_linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_gradient": function(node) {
          var orientation = visitor.visit(node.orientation);
          if (orientation) {
            orientation += ", ";
          }
          return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
        },
        "visit_shape": function(node) {
          var result = node.value, at3 = visitor.visit(node.at), style = visitor.visit(node.style);
          if (style) {
            result += " " + style;
          }
          if (at3) {
            result += " at " + at3;
          }
          return result;
        },
        "visit_default-radial": function(node) {
          var result = "", at3 = visitor.visit(node.at);
          if (at3) {
            result += at3;
          }
          return result;
        },
        "visit_extent-keyword": function(node) {
          var result = node.value, at3 = visitor.visit(node.at);
          if (at3) {
            result += " at " + at3;
          }
          return result;
        },
        "visit_position-keyword": function(node) {
          return node.value;
        },
        "visit_position": function(node) {
          return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
        },
        "visit_%": function(node) {
          return node.value + "%";
        },
        "visit_em": function(node) {
          return node.value + "em";
        },
        "visit_px": function(node) {
          return node.value + "px";
        },
        "visit_literal": function(node) {
          return visitor.visit_color(node.value, node);
        },
        "visit_hex": function(node) {
          return visitor.visit_color("#" + node.value, node);
        },
        "visit_rgb": function(node) {
          return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
        },
        "visit_rgba": function(node) {
          return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
        },
        "visit_color": function(resultColor, node) {
          var result = resultColor, length = visitor.visit(node.length);
          if (length) {
            result += " " + length;
          }
          return result;
        },
        "visit_angular": function(node) {
          return node.value + "deg";
        },
        "visit_directional": function(node) {
          return "to " + node.value;
        },
        "visit_array": function(elements) {
          var result = "", size = elements.length;
          elements.forEach(function(element, i3) {
            result += visitor.visit(element);
            if (i3 < size - 1) {
              result += ", ";
            }
          });
          return result;
        },
        "visit": function(element) {
          if (!element) {
            return "";
          }
          var result = "";
          if (element instanceof Array) {
            return visitor.visit_array(element, result);
          } else if (element.type) {
            var nodeVisitor = visitor["visit_" + element.type];
            if (nodeVisitor) {
              return nodeVisitor(element);
            } else {
              throw Error("Missing visitor visit_" + element.type);
            }
          } else {
            throw Error("Invalid node.");
          }
        }
      };
      return function(root) {
        return visitor.visit(root);
      };
    }();
    var GradientParser = GradientParser || {};
    GradientParser.parse = function() {
      var tokens = {
        linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
        repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
        radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
        repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /^\#([0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^rgb/i,
        rgbaColor: /^rgba/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
      };
      var input = "";
      function error(msg) {
        var err = new Error(input + ": " + msg);
        err.source = input;
        throw err;
      }
      function getAST() {
        var ast = matchListDefinitions();
        if (input.length > 0) {
          error("Invalid input not EOF");
        }
        return ast;
      }
      function matchListDefinitions() {
        return matchListing(matchDefinition);
      }
      function matchDefinition() {
        return matchGradient(
          "linear-gradient",
          tokens.linearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "repeating-linear-gradient",
          tokens.repeatingLinearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "radial-gradient",
          tokens.radialGradient,
          matchListRadialOrientations
        ) || matchGradient(
          "repeating-radial-gradient",
          tokens.repeatingRadialGradient,
          matchListRadialOrientations
        );
      }
      function matchGradient(gradientType, pattern, orientationMatcher) {
        return matchCall(pattern, function(captures) {
          var orientation = orientationMatcher();
          if (orientation) {
            if (!scan(tokens.comma)) {
              error("Missing comma before color stops");
            }
          }
          return {
            type: gradientType,
            orientation,
            colorStops: matchListing(matchColorStop)
          };
        });
      }
      function matchCall(pattern, callback) {
        var captures = scan(pattern);
        if (captures) {
          if (!scan(tokens.startCall)) {
            error("Missing (");
          }
          var result = callback(captures);
          if (!scan(tokens.endCall)) {
            error("Missing )");
          }
          return result;
        }
      }
      function matchLinearOrientation() {
        return matchSideOrCorner() || matchAngle();
      }
      function matchSideOrCorner() {
        return match("directional", tokens.sideOrCorner, 1);
      }
      function matchAngle() {
        return match("angular", tokens.angleValue, 1);
      }
      function matchListRadialOrientations() {
        var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
        if (radialOrientation) {
          radialOrientations = [];
          radialOrientations.push(radialOrientation);
          lookaheadCache = input;
          if (scan(tokens.comma)) {
            radialOrientation = matchRadialOrientation();
            if (radialOrientation) {
              radialOrientations.push(radialOrientation);
            } else {
              input = lookaheadCache;
            }
          }
        }
        return radialOrientations;
      }
      function matchRadialOrientation() {
        var radialType = matchCircle() || matchEllipse();
        if (radialType) {
          radialType.at = matchAtPosition();
        } else {
          var extent = matchExtentKeyword();
          if (extent) {
            radialType = extent;
            var positionAt = matchAtPosition();
            if (positionAt) {
              radialType.at = positionAt;
            }
          } else {
            var defaultPosition = matchPositioning();
            if (defaultPosition) {
              radialType = {
                type: "default-radial",
                at: defaultPosition
              };
            }
          }
        }
        return radialType;
      }
      function matchCircle() {
        var circle = match("shape", /^(circle)/i, 0);
        if (circle) {
          circle.style = matchLength() || matchExtentKeyword();
        }
        return circle;
      }
      function matchEllipse() {
        var ellipse = match("shape", /^(ellipse)/i, 0);
        if (ellipse) {
          ellipse.style = matchDistance() || matchExtentKeyword();
        }
        return ellipse;
      }
      function matchExtentKeyword() {
        return match("extent-keyword", tokens.extentKeywords, 1);
      }
      function matchAtPosition() {
        if (match("position", /^at/, 0)) {
          var positioning = matchPositioning();
          if (!positioning) {
            error("Missing positioning value");
          }
          return positioning;
        }
      }
      function matchPositioning() {
        var location2 = matchCoordinates();
        if (location2.x || location2.y) {
          return {
            type: "position",
            value: location2
          };
        }
      }
      function matchCoordinates() {
        return {
          x: matchDistance(),
          y: matchDistance()
        };
      }
      function matchListing(matcher) {
        var captures = matcher(), result = [];
        if (captures) {
          result.push(captures);
          while (scan(tokens.comma)) {
            captures = matcher();
            if (captures) {
              result.push(captures);
            } else {
              error("One extra comma");
            }
          }
        }
        return result;
      }
      function matchColorStop() {
        var color = matchColor();
        if (!color) {
          error("Expected color definition");
        }
        color.length = matchDistance();
        return color;
      }
      function matchColor() {
        return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
      }
      function matchLiteralColor() {
        return match("literal", tokens.literalColor, 0);
      }
      function matchHexColor() {
        return match("hex", tokens.hexColor, 1);
      }
      function matchRGBColor() {
        return matchCall(tokens.rgbColor, function() {
          return {
            type: "rgb",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchRGBAColor() {
        return matchCall(tokens.rgbaColor, function() {
          return {
            type: "rgba",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchNumber() {
        return scan(tokens.number)[1];
      }
      function matchDistance() {
        return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
      }
      function matchPositionKeyword() {
        return match("position-keyword", tokens.positionKeywords, 1);
      }
      function matchLength() {
        return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
      }
      function match(type, pattern, captureIndex) {
        var captures = scan(pattern);
        if (captures) {
          return {
            type,
            value: captures[captureIndex]
          };
        }
      }
      function scan(regexp) {
        var captures, blankCaptures;
        blankCaptures = /^[\n\r\t\s]+/.exec(input);
        if (blankCaptures) {
          consume(blankCaptures[0].length);
        }
        captures = regexp.exec(input);
        if (captures) {
          consume(captures[0].length);
        }
        return captures;
      }
      function consume(size) {
        input = input.substr(size);
      }
      return function(code) {
        input = code.toString();
        return getAST();
      };
    }();
    exports.parse = GradientParser.parse;
    exports.stringify = GradientParser.stringify;
  }
});

// node_modules/vue3-colorpicker/node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function isPlainObject(o3) {
  var ctor, prot;
  if (isObject(o3) === false)
    return false;
  ctor = o3.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/vue3-colorpicker/node_modules/vue-types/dist/vue-types.modern.js
function t() {
  return t = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r3 = arguments[t3];
      for (var n3 in r3)
        Object.prototype.hasOwnProperty.call(r3, n3) && (e2[n3] = r3[n3]);
    }
    return e2;
  }, t.apply(this, arguments);
}
function r(e2, t3) {
  if (null == e2)
    return {};
  var r3, n3, i3 = {}, o3 = Object.keys(e2);
  for (n3 = 0; n3 < o3.length; n3++)
    t3.indexOf(r3 = o3[n3]) >= 0 || (i3[r3] = e2[r3]);
  return i3;
}
var n = { silent: false, logLevel: "warn" };
var i = ["validator"];
var o = Object.prototype;
var a = o.toString;
var s = o.hasOwnProperty;
var u = /^\s*function (\w+)/;
function l(e2) {
  var t3;
  const r3 = null !== (t3 = null == e2 ? void 0 : e2.type) && void 0 !== t3 ? t3 : e2;
  if (r3) {
    const e3 = r3.toString().match(u);
    return e3 ? e3[1] : "";
  }
  return "";
}
var c = isPlainObject;
var f = (e2) => e2;
var d = f;
if (true) {
  const e2 = "undefined" != typeof console;
  d = e2 ? function(e3, t3 = n.logLevel) {
    false === n.silent && console[t3](`[VueTypes warn]: ${e3}`);
  } : f;
}
var p = (e2, t3) => s.call(e2, t3);
var y = Number.isInteger || function(e2) {
  return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
};
var v = Array.isArray || function(e2) {
  return "[object Array]" === a.call(e2);
};
var h = (e2) => "[object Function]" === a.call(e2);
var b = (e2) => c(e2) && p(e2, "_vueTypes_name");
var g = (e2) => c(e2) && (p(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t3) => p(e2, t3)));
function O(e2, t3) {
  return Object.defineProperty(e2.bind(t3), "__original", { value: e2 });
}
function m(e2, t3, r3 = false) {
  let n3, i3 = true, o3 = "";
  n3 = c(e2) ? e2 : { type: e2 };
  const a3 = b(n3) ? n3._vueTypes_name + " - " : "";
  if (g(n3) && null !== n3.type) {
    if (void 0 === n3.type || true === n3.type)
      return i3;
    if (!n3.required && void 0 === t3)
      return i3;
    v(n3.type) ? (i3 = n3.type.some((e3) => true === m(e3, t3, true)), o3 = n3.type.map((e3) => l(e3)).join(" or ")) : (o3 = l(n3), i3 = "Array" === o3 ? v(t3) : "Object" === o3 ? c(t3) : "String" === o3 || "Number" === o3 || "Boolean" === o3 || "Function" === o3 ? function(e3) {
      if (null == e3)
        return "";
      const t4 = e3.constructor.toString().match(u);
      return t4 ? t4[1] : "";
    }(t3) === o3 : t3 instanceof n3.type);
  }
  if (!i3) {
    const e3 = `${a3}value "${t3}" should be of type "${o3}"`;
    return false === r3 ? (d(e3), false) : e3;
  }
  if (p(n3, "validator") && h(n3.validator)) {
    const e3 = d, o4 = [];
    if (d = (e4) => {
      o4.push(e4);
    }, i3 = n3.validator(t3), d = e3, !i3) {
      const e4 = (o4.length > 1 ? "* " : "") + o4.join("\n* ");
      return o4.length = 0, false === r3 ? (d(e4), i3) : e4;
    }
  }
  return i3;
}
function j(e2, t3) {
  const r3 = Object.defineProperties(t3, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
    return this.required = true, this;
  } }, def: { value(e3) {
    return void 0 === e3 ? (p(this, "default") && delete this.default, this) : h(e3) || true === m(this, e3, true) ? (this.default = v(e3) ? () => [...e3] : c(e3) ? () => Object.assign({}, e3) : e3, this) : (d(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
  } } }), { validator: n3 } = r3;
  return h(n3) && (r3.validator = O(n3, r3)), r3;
}
function _(e2, t3) {
  const r3 = j(e2, t3);
  return Object.defineProperty(r3, "validate", { value(e3) {
    return h(this.validator) && d(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O(e3, this), this;
  } });
}
function T(e2, t3, n3) {
  const o3 = function(e3) {
    const t4 = {};
    return Object.getOwnPropertyNames(e3).forEach((r3) => {
      t4[r3] = Object.getOwnPropertyDescriptor(e3, r3);
    }), Object.defineProperties({}, t4);
  }(t3);
  if (o3._vueTypes_name = e2, !c(n3))
    return o3;
  const { validator: a3 } = n3, s3 = r(n3, i);
  if (h(a3)) {
    let { validator: e3 } = o3;
    e3 && (e3 = null !== (l3 = (u3 = e3).__original) && void 0 !== l3 ? l3 : u3), o3.validator = O(e3 ? function(t4) {
      return e3.call(this, t4) && a3.call(this, t4);
    } : a3, o3);
  }
  var u3, l3;
  return Object.assign(o3, s3);
}
function $(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
var w = () => _("any", {});
var P = () => _("function", { type: Function });
var x = () => _("boolean", { type: Boolean });
var E = () => _("string", { type: String });
var N = () => _("number", { type: Number });
var q = () => _("array", { type: Array });
var A = () => _("object", { type: Object });
var V = () => j("integer", { type: Number, validator: (e2) => y(e2) });
var S = () => j("symbol", { validator: (e2) => "symbol" == typeof e2 });
function D(e2, t3 = "custom validation failed") {
  if ("function" != typeof e2)
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return j(e2.name || "<<anonymous function>>", { type: null, validator(r3) {
    const n3 = e2(r3);
    return n3 || d(`${this._vueTypes_name} - ${t3}`), n3;
  } });
}
function L(e2) {
  if (!v(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const t3 = `oneOf - value should be one of "${e2.join('", "')}".`, r3 = e2.reduce((e3, t4) => {
    if (null != t4) {
      const r4 = t4.constructor;
      -1 === e3.indexOf(r4) && e3.push(r4);
    }
    return e3;
  }, []);
  return j("oneOf", { type: r3.length > 0 ? r3 : void 0, validator(r4) {
    const n3 = -1 !== e2.indexOf(r4);
    return n3 || d(t3), n3;
  } });
}
function F(e2) {
  if (!v(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let t3 = false, r3 = [];
  for (let n4 = 0; n4 < e2.length; n4 += 1) {
    const i3 = e2[n4];
    if (g(i3)) {
      if (b(i3) && "oneOf" === i3._vueTypes_name && i3.type) {
        r3 = r3.concat(i3.type);
        continue;
      }
      if (h(i3.validator) && (t3 = true), true === i3.type || !i3.type) {
        d('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      r3 = r3.concat(i3.type);
    } else
      r3.push(i3);
  }
  r3 = r3.filter((e3, t4) => r3.indexOf(e3) === t4);
  const n3 = r3.length > 0 ? r3 : null;
  return j("oneOfType", t3 ? { type: n3, validator(t4) {
    const r4 = [], n4 = e2.some((e3) => {
      const n5 = m(b(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t4, true);
      return "string" == typeof n5 && r4.push(n5), true === n5;
    });
    return n4 || d(`oneOfType - provided value does not match any of the ${r4.length} passed-in validators:
${$(r4.join("\n"))}`), n4;
  } } : { type: n3 });
}
function Y(e2) {
  return j("arrayOf", { type: Array, validator(t3) {
    let r3 = "";
    const n3 = t3.every((t4) => (r3 = m(e2, t4, true), true === r3));
    return n3 || d(`arrayOf - value validation error:
${$(r3)}`), n3;
  } });
}
function B(e2) {
  return j("instanceOf", { type: e2 });
}
function I(e2) {
  return j("objectOf", { type: Object, validator(t3) {
    let r3 = "";
    const n3 = Object.keys(t3).every((n4) => (r3 = m(e2, t3[n4], true), true === r3));
    return n3 || d(`objectOf - value validation error:
${$(r3)}`), n3;
  } });
}
function J(e2) {
  const t3 = Object.keys(e2), r3 = t3.filter((t4) => {
    var r4;
    return !(null === (r4 = e2[t4]) || void 0 === r4 || !r4.required);
  }), n3 = j("shape", { type: Object, validator(n4) {
    if (!c(n4))
      return false;
    const i3 = Object.keys(n4);
    if (r3.length > 0 && r3.some((e3) => -1 === i3.indexOf(e3))) {
      const e3 = r3.filter((e4) => -1 === i3.indexOf(e4));
      return d(1 === e3.length ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
    }
    return i3.every((r4) => {
      if (-1 === t3.indexOf(r4))
        return true === this._vueTypes_isLoose || (d(`shape - shape definition does not include a "${r4}" property. Allowed keys: "${t3.join('", "')}".`), false);
      const i4 = m(e2[r4], n4[r4], true);
      return "string" == typeof i4 && d(`shape - "${r4}" property validation error:
 ${$(i4)}`), true === i4;
    });
  } });
  return Object.defineProperty(n3, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n3, "loose", { get() {
    return this._vueTypes_isLoose = true, this;
  } }), n3;
}
var M = ["name", "validate", "getter"];
var R = (() => {
  var e2;
  return (e2 = class {
    static get any() {
      return w();
    }
    static get func() {
      return P().def(this.defaults.func);
    }
    static get bool() {
      return x().def(this.defaults.bool);
    }
    static get string() {
      return E().def(this.defaults.string);
    }
    static get number() {
      return N().def(this.defaults.number);
    }
    static get array() {
      return q().def(this.defaults.array);
    }
    static get object() {
      return A().def(this.defaults.object);
    }
    static get integer() {
      return V().def(this.defaults.integer);
    }
    static get symbol() {
      return S();
    }
    static get nullable() {
      return { type: null };
    }
    static extend(e3) {
      if (v(e3))
        return e3.forEach((e4) => this.extend(e4)), this;
      const { name: t3, validate: n3 = false, getter: i3 = false } = e3, o3 = r(e3, M);
      if (p(this, t3))
        throw new TypeError(`[VueTypes error]: Type "${t3}" already defined`);
      const { type: a3 } = o3;
      if (b(a3))
        return delete o3.type, Object.defineProperty(this, t3, i3 ? { get: () => T(t3, a3, o3) } : { value(...e4) {
          const r3 = T(t3, a3, o3);
          return r3.validator && (r3.validator = r3.validator.bind(r3, ...e4)), r3;
        } });
      let s3;
      return s3 = i3 ? { get() {
        const e4 = Object.assign({}, o3);
        return n3 ? _(t3, e4) : j(t3, e4);
      }, enumerable: true } : { value(...e4) {
        const r3 = Object.assign({}, o3);
        let i4;
        return i4 = n3 ? _(t3, r3) : j(t3, r3), r3.validator && (i4.validator = r3.validator.bind(i4, ...e4)), i4;
      }, enumerable: true }, Object.defineProperty(this, t3, s3);
    }
  }).defaults = {}, e2.sensibleDefaults = void 0, e2.config = n, e2.custom = D, e2.oneOf = L, e2.instanceOf = B, e2.oneOfType = F, e2.arrayOf = Y, e2.objectOf = I, e2.shape = J, e2.utils = { validate: (e3, t3) => true === m(t3, e3, true), toType: (e3, t3, r3 = false) => r3 ? _(e3, t3) : j(e3, t3) }, e2;
})();
function z(e2 = { func: () => {
}, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var r3;
  return (r3 = class extends R {
    static get sensibleDefaults() {
      return t({}, this.defaults);
    }
    static set sensibleDefaults(r4) {
      this.defaults = false !== r4 ? t({}, true !== r4 ? r4 : e2) : {};
    }
  }).defaults = t({}, e2), r3;
}
var C = class extends z() {
};

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R3, G3, B4;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R3 = RsRGB / 12.92;
    else
      R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G3 = GsRGB / 12.92;
    else
      G3 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B4 = BsRGB / 12.92;
    else
      B4 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R3 + 0.7152 * G3 + 0.0722 * B4;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h3 = Math.round(hsv.h * 360), s3 = Math.round(hsv.s * 100), v3 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h3 + ", " + s3 + "%, " + v3 + "%)" : "hsva(" + h3 + ", " + s3 + "%, " + v3 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h3 = Math.round(hsl.h * 360), s3 = Math.round(hsl.s * 100), l3 = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h3 + ", " + s3 + "%, " + l3 + "%)" : "hsla(" + h3 + ", " + s3 + "%, " + l3 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s3 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s3._r, s3._g, s3._b, s3._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn3, args) {
    var color = fn3.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn3, args) {
    return fn3.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i3 in color) {
      if (color.hasOwnProperty(i3)) {
        if (i3 === "a") {
          newColor[i3] = color[i3];
        } else {
          newColor[i3] = convertToPercentage(color[i3]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s3 = null;
  var v3 = null;
  var l3 = null;
  var ok = false;
  var format2 = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s3 = convertToPercentage(color.s);
      v3 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s3, v3);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s3 = convertToPercentage(color.s);
      l3 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s3, l3);
      ok = true;
      format2 = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a3 = color.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a3
  };
}
function rgbToRgb(r3, g3, b3) {
  return {
    r: bound01(r3, 255) * 255,
    g: bound01(g3, 255) * 255,
    b: bound01(b3, 255) * 255
  };
}
function rgbToHsl(r3, g3, b3) {
  r3 = bound01(r3, 255);
  g3 = bound01(g3, 255);
  b3 = bound01(b3, 255);
  var max2 = Math.max(r3, g3, b3), min2 = Math.min(r3, g3, b3);
  var h3, s3, l3 = (max2 + min2) / 2;
  if (max2 == min2) {
    h3 = s3 = 0;
  } else {
    var d3 = max2 - min2;
    s3 = l3 > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
    switch (max2) {
      case r3:
        h3 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
        break;
      case g3:
        h3 = (b3 - r3) / d3 + 2;
        break;
      case b3:
        h3 = (r3 - g3) / d3 + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s: s3,
    l: l3
  };
}
function hslToRgb(h3, s3, l3) {
  var r3, g3, b3;
  h3 = bound01(h3, 360);
  s3 = bound01(s3, 100);
  l3 = bound01(l3, 100);
  function hue2rgb(p4, q3, t3) {
    if (t3 < 0)
      t3 += 1;
    if (t3 > 1)
      t3 -= 1;
    if (t3 < 1 / 6)
      return p4 + (q3 - p4) * 6 * t3;
    if (t3 < 1 / 2)
      return q3;
    if (t3 < 2 / 3)
      return p4 + (q3 - p4) * (2 / 3 - t3) * 6;
    return p4;
  }
  if (s3 === 0) {
    r3 = g3 = b3 = l3;
  } else {
    var q2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
    var p3 = 2 * l3 - q2;
    r3 = hue2rgb(p3, q2, h3 + 1 / 3);
    g3 = hue2rgb(p3, q2, h3);
    b3 = hue2rgb(p3, q2, h3 - 1 / 3);
  }
  return {
    r: r3 * 255,
    g: g3 * 255,
    b: b3 * 255
  };
}
function rgbToHsv(r3, g3, b3) {
  r3 = bound01(r3, 255);
  g3 = bound01(g3, 255);
  b3 = bound01(b3, 255);
  var max2 = Math.max(r3, g3, b3), min2 = Math.min(r3, g3, b3);
  var h3, s3, v3 = max2;
  var d3 = max2 - min2;
  s3 = max2 === 0 ? 0 : d3 / max2;
  if (max2 == min2) {
    h3 = 0;
  } else {
    switch (max2) {
      case r3:
        h3 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
        break;
      case g3:
        h3 = (b3 - r3) / d3 + 2;
        break;
      case b3:
        h3 = (r3 - g3) / d3 + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s: s3,
    v: v3
  };
}
function hsvToRgb(h3, s3, v3) {
  h3 = bound01(h3, 360) * 6;
  s3 = bound01(s3, 100);
  v3 = bound01(v3, 100);
  var i3 = Math.floor(h3), f3 = h3 - i3, p3 = v3 * (1 - s3), q2 = v3 * (1 - f3 * s3), t3 = v3 * (1 - (1 - f3) * s3), mod = i3 % 6, r3 = [v3, q2, p3, p3, t3, v3][mod], g3 = [t3, v3, v3, q2, p3, p3][mod], b3 = [p3, p3, t3, v3, v3, q2][mod];
  return {
    r: r3 * 255,
    g: g3 * 255,
    b: b3 * 255
  };
}
function rgbToHex(r3, g3, b3, allow3Char) {
  var hex = [pad2(Math.round(r3).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b3).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r3, g3, b3, a3, allow4Char) {
  var hex = [pad2(Math.round(r3).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b3).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r3, g3, b3, a3) {
  var hex = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r3).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b3).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i3 = 1; i3 < number; i3++) {
    result.push(tinycolor({
      h: (hsl.h + i3 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h3 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h3 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h3 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h3 = hsv.h, s3 = hsv.s, v3 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h3,
      s: s3,
      v: v3
    }));
    v3 = (v3 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p3 = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p3 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p3 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p3 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p3 + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i3 = 0; i3 < colorList.length; i3++) {
    readability = tinycolor.readability(baseColor, colorList[i3]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i3]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o3) {
  var flipped = {};
  for (var i3 in o3) {
    if (o3.hasOwnProperty(i3)) {
      flipped[o3[i3]] = i3;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n3, max2) {
  if (isOnePointZero(n3))
    n3 = "100%";
  var processPercent = isPercentage(n3);
  n3 = Math.min(max2, Math.max(0, parseFloat(n3)));
  if (processPercent) {
    n3 = parseInt(n3 * max2, 10) / 100;
  }
  if (Math.abs(n3 - max2) < 1e-6) {
    return 1;
  }
  return n3 % max2 / parseFloat(max2);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n3) {
  return typeof n3 == "string" && n3.indexOf(".") != -1 && parseFloat(n3) === 1;
}
function isPercentage(n3) {
  return typeof n3 === "string" && n3.indexOf("%") != -1;
}
function pad2(c3) {
  return c3.length == 1 ? "0" + c3 : "" + c3;
}
function convertToPercentage(n3) {
  if (n3 <= 1) {
    n3 = n3 * 100 + "%";
  }
  return n3;
}
function convertDecimalToHex(d3) {
  return Math.round(parseFloat(d3) * 255).toString(16);
}
function convertHexToDecimal(h3) {
  return parseIntFromHex(h3) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// node_modules/@vueuse/core/node_modules/@vueuse/shared/index.mjs
function tryOnScopeDispose(fn3) {
  if (getCurrentScope()) {
    onScopeDispose(fn3);
    return true;
  }
  return false;
}
var isClient = typeof window !== "undefined";
var isString = (val) => typeof val === "string";
var noop = () => {
};
function createFilterWrapper(filter, fn3) {
  function wrapper(...args) {
    filter(() => fn3.apply(this, args), { fn: fn3, thisArg: this, args });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function useDebounceFn(fn3, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn3);
}
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$5(_a, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function tryOnMounted(fn3, sync = true) {
  if (getCurrentInstance())
    onMounted(fn3);
  else if (sync)
    fn3();
  else
    nextTick(fn3);
}
function whenever(source, cb, options) {
  return watch(source, (v3, ov, onInvalidate) => {
    if (v3)
      cb(v3, ov, onInvalidate);
  }, options);
}

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a;
  const plain = unref(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, event = "pointerdown" } = options;
  if (!window2)
    return;
  const listener = (event2) => {
    const el = unrefElement(target);
    if (!el)
      return;
    if (el === event2.target || event2.composedPath().includes(el))
      return;
    handler(event2);
  };
  return useEventListener(window2, event, listener, { passive: true });
}
var StorageSerializers = {
  boolean: {
    read: (v3) => v3 === "true",
    write: (v3) => String(v3)
  },
  object: {
    read: (v3) => JSON.parse(v3),
    write: (v3) => JSON.stringify(v3)
  },
  number: {
    read: (v3) => Number.parseFloat(v3),
    write: (v3) => String(v3)
  },
  any: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  string: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  map: {
    read: (v3) => new Map(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3.entries()))
  },
  set: {
    read: (v3) => new Set(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3.entries()))
  }
};
function useStorage(key, initialValue, storage = ((_a) => (_a = defaultWindow) == null ? void 0 : _a.localStorage)(), options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const rawInit = unref(initialValue);
  const type = rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
  const data = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  function read2(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        data.value = rawInit;
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
      } else {
        data.value = serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    }
  }
  read2();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e2) => setTimeout(() => read2(e2), 0));
  if (storage) {
    watchWithFilter(data, () => {
      try {
        if (data.value == null)
          storage.removeItem(key);
        else
          storage.setItem(key, serializer.write(data.value));
      } catch (e2) {
        onError(e2);
      }
    }, {
      flush,
      deep,
      eventFilter
    });
  }
  return data;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));

// node_modules/@aesoper/normal-utils/NormalUtils.es.js
var t2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function e(t3) {
  var e2 = { exports: {} };
  return t3(e2, e2.exports), e2.exports;
}
var n2 = function(t3) {
  return t3 && t3.Math == Math && t3;
};
var r2 = n2("object" == typeof globalThis && globalThis) || n2("object" == typeof window && window) || n2("object" == typeof self && self) || n2("object" == typeof t2 && t2) || function() {
  return this;
}() || Function("return this")();
var o2 = function(t3) {
  try {
    return !!t3();
  } catch (t4) {
    return true;
  }
};
var i2 = !o2(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
});
var u2 = {}.propertyIsEnumerable;
var a2 = Object.getOwnPropertyDescriptor;
var c2 = { f: a2 && !u2.call({ 1: 2 }, 1) ? function(t3) {
  var e2 = a2(this, t3);
  return !!e2 && e2.enumerable;
} : u2 };
var l2 = function(t3, e2) {
  return { enumerable: !(1 & t3), configurable: !(2 & t3), writable: !(4 & t3), value: e2 };
};
var f2 = {}.toString;
var s2 = function(t3) {
  return f2.call(t3).slice(8, -1);
};
var d2 = "".split;
var v2 = o2(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(t3) {
  return "String" == s2(t3) ? d2.call(t3, "") : Object(t3);
} : Object;
var p2 = function(t3) {
  if (null == t3)
    throw TypeError("Can't call method on " + t3);
  return t3;
};
var g2 = function(t3) {
  return v2(p2(t3));
};
var h2 = function(t3) {
  return "object" == typeof t3 ? null !== t3 : "function" == typeof t3;
};
var y2 = function(t3, e2) {
  if (!h2(t3))
    return t3;
  var n3, r3;
  if (e2 && "function" == typeof (n3 = t3.toString) && !h2(r3 = n3.call(t3)))
    return r3;
  if ("function" == typeof (n3 = t3.valueOf) && !h2(r3 = n3.call(t3)))
    return r3;
  if (!e2 && "function" == typeof (n3 = t3.toString) && !h2(r3 = n3.call(t3)))
    return r3;
  throw TypeError("Can't convert object to primitive value");
};
var m2 = {}.hasOwnProperty;
var S2 = function(t3, e2) {
  return m2.call(t3, e2);
};
var x2 = r2.document;
var b2 = h2(x2) && h2(x2.createElement);
var E2 = function(t3) {
  return b2 ? x2.createElement(t3) : {};
};
var w2 = !i2 && !o2(function() {
  return 7 != Object.defineProperty(E2("div"), "a", { get: function() {
    return 7;
  } }).a;
});
var O2 = Object.getOwnPropertyDescriptor;
var T2 = { f: i2 ? O2 : function(t3, e2) {
  if (t3 = g2(t3), e2 = y2(e2, true), w2)
    try {
      return O2(t3, e2);
    } catch (t4) {
    }
  if (S2(t3, e2))
    return l2(!c2.f.call(t3, e2), t3[e2]);
} };
var A2 = function(t3) {
  if (!h2(t3))
    throw TypeError(String(t3) + " is not an object");
  return t3;
};
var k = Object.defineProperty;
var R2 = { f: i2 ? k : function(t3, e2, n3) {
  if (A2(t3), e2 = y2(e2, true), A2(n3), w2)
    try {
      return k(t3, e2, n3);
    } catch (t4) {
    }
  if ("get" in n3 || "set" in n3)
    throw TypeError("Accessors not supported");
  return "value" in n3 && (t3[e2] = n3.value), t3;
} };
var I2 = i2 ? function(t3, e2, n3) {
  return R2.f(t3, e2, l2(1, n3));
} : function(t3, e2, n3) {
  return t3[e2] = n3, t3;
};
var j2 = function(t3, e2) {
  try {
    I2(r2, t3, e2);
  } catch (n3) {
    r2[t3] = e2;
  }
  return e2;
};
var C2 = r2["__core-js_shared__"] || j2("__core-js_shared__", {});
var L2 = Function.toString;
"function" != typeof C2.inspectSource && (C2.inspectSource = function(t3) {
  return L2.call(t3);
});
var P2;
var M2;
var _2;
var D2 = C2.inspectSource;
var U = r2.WeakMap;
var N2 = "function" == typeof U && /native code/.test(D2(U));
var F2 = e(function(t3) {
  (t3.exports = function(t4, e2) {
    return C2[t4] || (C2[t4] = void 0 !== e2 ? e2 : {});
  })("versions", []).push({ version: "3.8.3", mode: "global", copyright: " 2021 Denis Pushkarev (zloirock.ru)" });
});
var W = 0;
var z2 = Math.random();
var $2 = function(t3) {
  return "Symbol(" + String(void 0 === t3 ? "" : t3) + ")_" + (++W + z2).toString(36);
};
var B2 = F2("keys");
var Y2 = function(t3) {
  return B2[t3] || (B2[t3] = $2(t3));
};
var G = {};
var H = r2.WeakMap;
if (N2) {
  X = C2.state || (C2.state = new H()), V2 = X.get, K = X.has, q2 = X.set;
  P2 = function(t3, e2) {
    return e2.facade = t3, q2.call(X, t3, e2), e2;
  }, M2 = function(t3) {
    return V2.call(X, t3) || {};
  }, _2 = function(t3) {
    return K.call(X, t3);
  };
} else {
  Q = Y2("state");
  G[Q] = true, P2 = function(t3, e2) {
    return e2.facade = t3, I2(t3, Q, e2), e2;
  }, M2 = function(t3) {
    return S2(t3, Q) ? t3[Q] : {};
  }, _2 = function(t3) {
    return S2(t3, Q);
  };
}
var X;
var V2;
var K;
var q2;
var Q;
var J2 = { set: P2, get: M2, has: _2, enforce: function(t3) {
  return _2(t3) ? M2(t3) : P2(t3, {});
}, getterFor: function(t3) {
  return function(e2) {
    var n3;
    if (!h2(e2) || (n3 = M2(e2)).type !== t3)
      throw TypeError("Incompatible receiver, " + t3 + " required");
    return n3;
  };
} };
var Z = e(function(t3) {
  var e2 = J2.get, n3 = J2.enforce, o3 = String(String).split("String");
  (t3.exports = function(t4, e3, i3, u3) {
    var a3, c3 = !!u3 && !!u3.unsafe, l3 = !!u3 && !!u3.enumerable, f3 = !!u3 && !!u3.noTargetGet;
    "function" == typeof i3 && ("string" != typeof e3 || S2(i3, "name") || I2(i3, "name", e3), (a3 = n3(i3)).source || (a3.source = o3.join("string" == typeof e3 ? e3 : ""))), t4 !== r2 ? (c3 ? !f3 && t4[e3] && (l3 = true) : delete t4[e3], l3 ? t4[e3] = i3 : I2(t4, e3, i3)) : l3 ? t4[e3] = i3 : j2(e3, i3);
  })(Function.prototype, "toString", function() {
    return "function" == typeof this && e2(this).source || D2(this);
  });
});
var tt = r2;
var et = function(t3) {
  return "function" == typeof t3 ? t3 : void 0;
};
var nt = function(t3, e2) {
  return arguments.length < 2 ? et(tt[t3]) || et(r2[t3]) : tt[t3] && tt[t3][e2] || r2[t3] && r2[t3][e2];
};
var rt = Math.ceil;
var ot = Math.floor;
var it = function(t3) {
  return isNaN(t3 = +t3) ? 0 : (t3 > 0 ? ot : rt)(t3);
};
var ut = Math.min;
var at = function(t3) {
  return t3 > 0 ? ut(it(t3), 9007199254740991) : 0;
};
var ct = Math.max;
var lt = Math.min;
var ft = function(t3, e2) {
  var n3 = it(t3);
  return n3 < 0 ? ct(n3 + e2, 0) : lt(n3, e2);
};
var st = function(t3) {
  return function(e2, n3, r3) {
    var o3, i3 = g2(e2), u3 = at(i3.length), a3 = ft(r3, u3);
    if (t3 && n3 != n3) {
      for (; u3 > a3; )
        if ((o3 = i3[a3++]) != o3)
          return true;
    } else
      for (; u3 > a3; a3++)
        if ((t3 || a3 in i3) && i3[a3] === n3)
          return t3 || a3 || 0;
    return !t3 && -1;
  };
};
var dt = { includes: st(true), indexOf: st(false) };
var vt = dt.indexOf;
var pt = function(t3, e2) {
  var n3, r3 = g2(t3), o3 = 0, i3 = [];
  for (n3 in r3)
    !S2(G, n3) && S2(r3, n3) && i3.push(n3);
  for (; e2.length > o3; )
    S2(r3, n3 = e2[o3++]) && (~vt(i3, n3) || i3.push(n3));
  return i3;
};
var gt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var ht = gt.concat("length", "prototype");
var yt = { f: Object.getOwnPropertyNames || function(t3) {
  return pt(t3, ht);
} };
var mt = { f: Object.getOwnPropertySymbols };
var St = nt("Reflect", "ownKeys") || function(t3) {
  var e2 = yt.f(A2(t3)), n3 = mt.f;
  return n3 ? e2.concat(n3(t3)) : e2;
};
var xt = function(t3, e2) {
  for (var n3 = St(e2), r3 = R2.f, o3 = T2.f, i3 = 0; i3 < n3.length; i3++) {
    var u3 = n3[i3];
    S2(t3, u3) || r3(t3, u3, o3(e2, u3));
  }
};
var bt = /#|\.prototype\./;
var Et = function(t3, e2) {
  var n3 = Ot[wt(t3)];
  return n3 == At || n3 != Tt && ("function" == typeof e2 ? o2(e2) : !!e2);
};
var wt = Et.normalize = function(t3) {
  return String(t3).replace(bt, ".").toLowerCase();
};
var Ot = Et.data = {};
var Tt = Et.NATIVE = "N";
var At = Et.POLYFILL = "P";
var kt = Et;
var Rt = T2.f;
var It = function(t3, e2) {
  var n3, o3, i3, u3, a3, c3 = t3.target, l3 = t3.global, f3 = t3.stat;
  if (n3 = l3 ? r2 : f3 ? r2[c3] || j2(c3, {}) : (r2[c3] || {}).prototype)
    for (o3 in e2) {
      if (u3 = e2[o3], i3 = t3.noTargetGet ? (a3 = Rt(n3, o3)) && a3.value : n3[o3], !kt(l3 ? o3 : c3 + (f3 ? "." : "#") + o3, t3.forced) && void 0 !== i3) {
        if (typeof u3 == typeof i3)
          continue;
        xt(u3, i3);
      }
      (t3.sham || i3 && i3.sham) && I2(u3, "sham", true), Z(n3, o3, u3, t3);
    }
};
var jt = function(t3, e2) {
  var n3 = [][t3];
  return !!n3 && o2(function() {
    n3.call(null, e2 || function() {
      throw 1;
    }, 1);
  });
};
var Ct = Object.defineProperty;
var Lt = {};
var Pt = function(t3) {
  throw t3;
};
var Mt = function(t3, e2) {
  if (S2(Lt, t3))
    return Lt[t3];
  e2 || (e2 = {});
  var n3 = [][t3], r3 = !!S2(e2, "ACCESSORS") && e2.ACCESSORS, u3 = S2(e2, 0) ? e2[0] : Pt, a3 = S2(e2, 1) ? e2[1] : void 0;
  return Lt[t3] = !!n3 && !o2(function() {
    if (r3 && !i2)
      return true;
    var t4 = { length: -1 };
    r3 ? Ct(t4, 1, { enumerable: true, get: Pt }) : t4[1] = 1, n3.call(t4, u3, a3);
  });
};
var _t = dt.indexOf;
var Dt = [].indexOf;
var Ut = !!Dt && 1 / [1].indexOf(1, -0) < 0;
var Nt = jt("indexOf");
var Ft = Mt("indexOf", { ACCESSORS: true, 1: 0 });
function Wt(t3, e2) {
  if (!(t3 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
}
function zt(t3, e2) {
  for (var n3 = 0; n3 < e2.length; n3++) {
    var r3 = e2[n3];
    r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t3, r3.key, r3);
  }
}
function $t(t3, e2, n3) {
  return e2 && zt(t3.prototype, e2), n3 && zt(t3, n3), t3;
}
It({ target: "Array", proto: true, forced: Ut || !Nt || !Ft }, { indexOf: function(t3) {
  return Ut ? Dt.apply(this, arguments) || 0 : _t(this, t3, arguments.length > 1 ? arguments[1] : void 0);
} });
var Bt = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "isInBrowser", value: function() {
    return "undefined" != typeof window;
  } }, { key: "isServer", value: function() {
    return "undefined" == typeof window;
  } }, { key: "getUA", value: function() {
    return t3.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
  } }, { key: "isMobile", value: function() {
    return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
  } }, { key: "isOpera", value: function() {
    return -1 !== navigator.userAgent.indexOf("Opera");
  } }, { key: "isIE", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && e2.indexOf("msie") > 0;
  } }, { key: "isIE9", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && e2.indexOf("msie 9.0") > 0;
  } }, { key: "isEdge", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && e2.indexOf("edge/") > 0;
  } }, { key: "isChrome", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && /chrome\/\d+/.test(e2) && !t3.isEdge();
  } }, { key: "isPhantomJS", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && /phantomjs/.test(e2);
  } }, { key: "isFirefox", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && /firefox/.test(e2);
  } }]), t3;
}();
var Yt = [].join;
var Gt = v2 != Object;
var Ht = jt("join", ",");
It({ target: "Array", proto: true, forced: Gt || !Ht }, { join: function(t3) {
  return Yt.call(g2(this), void 0 === t3 ? "," : t3);
} });
var Xt;
var Vt;
var Kt = function(t3) {
  return Object(p2(t3));
};
var qt = Array.isArray || function(t3) {
  return "Array" == s2(t3);
};
var Qt = !!Object.getOwnPropertySymbols && !o2(function() {
  return !String(Symbol());
});
var Jt = Qt && !Symbol.sham && "symbol" == typeof Symbol.iterator;
var Zt = F2("wks");
var te = r2.Symbol;
var ee = Jt ? te : te && te.withoutSetter || $2;
var ne = function(t3) {
  return S2(Zt, t3) || (Qt && S2(te, t3) ? Zt[t3] = te[t3] : Zt[t3] = ee("Symbol." + t3)), Zt[t3];
};
var re = ne("species");
var oe = function(t3, e2) {
  var n3;
  return qt(t3) && ("function" != typeof (n3 = t3.constructor) || n3 !== Array && !qt(n3.prototype) ? h2(n3) && null === (n3 = n3[re]) && (n3 = void 0) : n3 = void 0), new (void 0 === n3 ? Array : n3)(0 === e2 ? 0 : e2);
};
var ie = function(t3, e2, n3) {
  var r3 = y2(e2);
  r3 in t3 ? R2.f(t3, r3, l2(0, n3)) : t3[r3] = n3;
};
var ue = nt("navigator", "userAgent") || "";
var ae = r2.process;
var ce = ae && ae.versions;
var le = ce && ce.v8;
le ? Vt = (Xt = le.split("."))[0] + Xt[1] : ue && (!(Xt = ue.match(/Edge\/(\d+)/)) || Xt[1] >= 74) && (Xt = ue.match(/Chrome\/(\d+)/)) && (Vt = Xt[1]);
var fe = Vt && +Vt;
var se = ne("species");
var de = function(t3) {
  return fe >= 51 || !o2(function() {
    var e2 = [];
    return (e2.constructor = {})[se] = function() {
      return { foo: 1 };
    }, 1 !== e2[t3](Boolean).foo;
  });
};
var ve = de("splice");
var pe = Mt("splice", { ACCESSORS: true, 0: 0, 1: 2 });
var ge = Math.max;
var he = Math.min;
It({ target: "Array", proto: true, forced: !ve || !pe }, { splice: function(t3, e2) {
  var n3, r3, o3, i3, u3, a3, c3 = Kt(this), l3 = at(c3.length), f3 = ft(t3, l3), s3 = arguments.length;
  if (0 === s3 ? n3 = r3 = 0 : 1 === s3 ? (n3 = 0, r3 = l3 - f3) : (n3 = s3 - 2, r3 = he(ge(it(e2), 0), l3 - f3)), l3 + n3 - r3 > 9007199254740991)
    throw TypeError("Maximum allowed length exceeded");
  for (o3 = oe(c3, r3), i3 = 0; i3 < r3; i3++)
    (u3 = f3 + i3) in c3 && ie(o3, i3, c3[u3]);
  if (o3.length = r3, n3 < r3) {
    for (i3 = f3; i3 < l3 - r3; i3++)
      a3 = i3 + n3, (u3 = i3 + r3) in c3 ? c3[a3] = c3[u3] : delete c3[a3];
    for (i3 = l3; i3 > l3 - r3 + n3; i3--)
      delete c3[i3 - 1];
  } else if (n3 > r3)
    for (i3 = l3 - r3; i3 > f3; i3--)
      a3 = i3 + n3 - 1, (u3 = i3 + r3 - 1) in c3 ? c3[a3] = c3[u3] : delete c3[a3];
  for (i3 = 0; i3 < n3; i3++)
    c3[i3 + f3] = arguments[i3 + 2];
  return c3.length = l3 - r3 + n3, o3;
} });
var ye = {};
ye[ne("toStringTag")] = "z";
var me = "[object z]" === String(ye);
var Se = ne("toStringTag");
var xe = "Arguments" == s2(function() {
  return arguments;
}());
var be = me ? s2 : function(t3) {
  var e2, n3, r3;
  return void 0 === t3 ? "Undefined" : null === t3 ? "Null" : "string" == typeof (n3 = function(t4, e3) {
    try {
      return t4[e3];
    } catch (t5) {
    }
  }(e2 = Object(t3), Se)) ? n3 : xe ? s2(e2) : "Object" == (r3 = s2(e2)) && "function" == typeof e2.callee ? "Arguments" : r3;
};
var Ee = me ? {}.toString : function() {
  return "[object " + be(this) + "]";
};
me || Z(Object.prototype, "toString", Ee, { unsafe: true });
var we = function() {
  var t3 = A2(this), e2 = "";
  return t3.global && (e2 += "g"), t3.ignoreCase && (e2 += "i"), t3.multiline && (e2 += "m"), t3.dotAll && (e2 += "s"), t3.unicode && (e2 += "u"), t3.sticky && (e2 += "y"), e2;
};
function Oe(t3, e2) {
  return RegExp(t3, e2);
}
var Te;
var Ae;
var ke = { UNSUPPORTED_Y: o2(function() {
  var t3 = Oe("a", "y");
  return t3.lastIndex = 2, null != t3.exec("abcd");
}), BROKEN_CARET: o2(function() {
  var t3 = Oe("^r", "gy");
  return t3.lastIndex = 2, null != t3.exec("str");
}) };
var Re = RegExp.prototype.exec;
var Ie = String.prototype.replace;
var je = Re;
var Ce = (Te = /a/, Ae = /b*/g, Re.call(Te, "a"), Re.call(Ae, "a"), 0 !== Te.lastIndex || 0 !== Ae.lastIndex);
var Le = ke.UNSUPPORTED_Y || ke.BROKEN_CARET;
var Pe = void 0 !== /()??/.exec("")[1];
(Ce || Pe || Le) && (je = function(t3) {
  var e2, n3, r3, o3, i3 = this, u3 = Le && i3.sticky, a3 = we.call(i3), c3 = i3.source, l3 = 0, f3 = t3;
  return u3 && (-1 === (a3 = a3.replace("y", "")).indexOf("g") && (a3 += "g"), f3 = String(t3).slice(i3.lastIndex), i3.lastIndex > 0 && (!i3.multiline || i3.multiline && "\n" !== t3[i3.lastIndex - 1]) && (c3 = "(?: " + c3 + ")", f3 = " " + f3, l3++), n3 = new RegExp("^(?:" + c3 + ")", a3)), Pe && (n3 = new RegExp("^" + c3 + "$(?!\\s)", a3)), Ce && (e2 = i3.lastIndex), r3 = Re.call(u3 ? n3 : i3, f3), u3 ? r3 ? (r3.input = r3.input.slice(l3), r3[0] = r3[0].slice(l3), r3.index = i3.lastIndex, i3.lastIndex += r3[0].length) : i3.lastIndex = 0 : Ce && r3 && (i3.lastIndex = i3.global ? r3.index + r3[0].length : e2), Pe && r3 && r3.length > 1 && Ie.call(r3[0], n3, function() {
    for (o3 = 1; o3 < arguments.length - 2; o3++)
      void 0 === arguments[o3] && (r3[o3] = void 0);
  }), r3;
});
var Me = je;
It({ target: "RegExp", proto: true, forced: /./.exec !== Me }, { exec: Me });
var _e = RegExp.prototype;
var De = _e.toString;
var Ue = o2(function() {
  return "/a/b" != De.call({ source: "a", flags: "b" });
});
var Ne = "toString" != De.name;
(Ue || Ne) && Z(RegExp.prototype, "toString", function() {
  var t3 = A2(this), e2 = String(t3.source), n3 = t3.flags;
  return "/" + e2 + "/" + String(void 0 === n3 && t3 instanceof RegExp && !("flags" in _e) ? we.call(t3) : n3);
}, { unsafe: true });
var Fe = ne("species");
var We = !o2(function() {
  var t3 = /./;
  return t3.exec = function() {
    var t4 = [];
    return t4.groups = { a: "7" }, t4;
  }, "7" !== "".replace(t3, "$<a>");
});
var ze = "$0" === "a".replace(/./, "$0");
var $e = ne("replace");
var Be = !!/./[$e] && "" === /./[$e]("a", "$0");
var Ye = !o2(function() {
  var t3 = /(?:)/, e2 = t3.exec;
  t3.exec = function() {
    return e2.apply(this, arguments);
  };
  var n3 = "ab".split(t3);
  return 2 !== n3.length || "a" !== n3[0] || "b" !== n3[1];
});
var Ge = function(t3, e2, n3, r3) {
  var i3 = ne(t3), u3 = !o2(function() {
    var e3 = {};
    return e3[i3] = function() {
      return 7;
    }, 7 != ""[t3](e3);
  }), a3 = u3 && !o2(function() {
    var e3 = false, n4 = /a/;
    return "split" === t3 && ((n4 = {}).constructor = {}, n4.constructor[Fe] = function() {
      return n4;
    }, n4.flags = "", n4[i3] = /./[i3]), n4.exec = function() {
      return e3 = true, null;
    }, n4[i3](""), !e3;
  });
  if (!u3 || !a3 || "replace" === t3 && (!We || !ze || Be) || "split" === t3 && !Ye) {
    var c3 = /./[i3], l3 = n3(i3, ""[t3], function(t4, e3, n4, r4, o3) {
      return e3.exec === Me ? u3 && !o3 ? { done: true, value: c3.call(e3, n4, r4) } : { done: true, value: t4.call(n4, e3, r4) } : { done: false };
    }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f3 = l3[0], s3 = l3[1];
    Z(String.prototype, t3, f3), Z(RegExp.prototype, i3, 2 == e2 ? function(t4, e3) {
      return s3.call(t4, this, e3);
    } : function(t4) {
      return s3.call(t4, this);
    });
  }
  r3 && I2(RegExp.prototype[i3], "sham", true);
};
var He = ne("match");
var Xe = function(t3) {
  var e2;
  return h2(t3) && (void 0 !== (e2 = t3[He]) ? !!e2 : "RegExp" == s2(t3));
};
var Ve = function(t3) {
  if ("function" != typeof t3)
    throw TypeError(String(t3) + " is not a function");
  return t3;
};
var Ke = ne("species");
var qe = function(t3) {
  return function(e2, n3) {
    var r3, o3, i3 = String(p2(e2)), u3 = it(n3), a3 = i3.length;
    return u3 < 0 || u3 >= a3 ? t3 ? "" : void 0 : (r3 = i3.charCodeAt(u3)) < 55296 || r3 > 56319 || u3 + 1 === a3 || (o3 = i3.charCodeAt(u3 + 1)) < 56320 || o3 > 57343 ? t3 ? i3.charAt(u3) : r3 : t3 ? i3.slice(u3, u3 + 2) : o3 - 56320 + (r3 - 55296 << 10) + 65536;
  };
};
var Qe = { codeAt: qe(false), charAt: qe(true) };
var Je = Qe.charAt;
var Ze = function(t3, e2, n3) {
  return e2 + (n3 ? Je(t3, e2).length : 1);
};
var tn = function(t3, e2) {
  var n3 = t3.exec;
  if ("function" == typeof n3) {
    var r3 = n3.call(t3, e2);
    if ("object" != typeof r3)
      throw TypeError("RegExp exec method returned something other than an Object or null");
    return r3;
  }
  if ("RegExp" !== s2(t3))
    throw TypeError("RegExp#exec called on incompatible receiver");
  return Me.call(t3, e2);
};
var en = [].push;
var nn = Math.min;
var rn = !o2(function() {
  return !RegExp(4294967295, "y");
});
Ge("split", 2, function(t3, e2, n3) {
  var r3;
  return r3 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t4, n4) {
    var r4 = String(p2(this)), o3 = void 0 === n4 ? 4294967295 : n4 >>> 0;
    if (0 === o3)
      return [];
    if (void 0 === t4)
      return [r4];
    if (!Xe(t4))
      return e2.call(r4, t4, o3);
    for (var i3, u3, a3, c3 = [], l3 = (t4.ignoreCase ? "i" : "") + (t4.multiline ? "m" : "") + (t4.unicode ? "u" : "") + (t4.sticky ? "y" : ""), f3 = 0, s3 = new RegExp(t4.source, l3 + "g"); (i3 = Me.call(s3, r4)) && !((u3 = s3.lastIndex) > f3 && (c3.push(r4.slice(f3, i3.index)), i3.length > 1 && i3.index < r4.length && en.apply(c3, i3.slice(1)), a3 = i3[0].length, f3 = u3, c3.length >= o3)); )
      s3.lastIndex === i3.index && s3.lastIndex++;
    return f3 === r4.length ? !a3 && s3.test("") || c3.push("") : c3.push(r4.slice(f3)), c3.length > o3 ? c3.slice(0, o3) : c3;
  } : "0".split(void 0, 0).length ? function(t4, n4) {
    return void 0 === t4 && 0 === n4 ? [] : e2.call(this, t4, n4);
  } : e2, [function(e3, n4) {
    var o3 = p2(this), i3 = null == e3 ? void 0 : e3[t3];
    return void 0 !== i3 ? i3.call(e3, o3, n4) : r3.call(String(o3), e3, n4);
  }, function(t4, o3) {
    var i3 = n3(r3, t4, this, o3, r3 !== e2);
    if (i3.done)
      return i3.value;
    var u3 = A2(t4), a3 = String(this), c3 = function(t5, e3) {
      var n4, r4 = A2(t5).constructor;
      return void 0 === r4 || null == (n4 = A2(r4)[Ke]) ? e3 : Ve(n4);
    }(u3, RegExp), l3 = u3.unicode, f3 = (u3.ignoreCase ? "i" : "") + (u3.multiline ? "m" : "") + (u3.unicode ? "u" : "") + (rn ? "y" : "g"), s3 = new c3(rn ? u3 : "^(?:" + u3.source + ")", f3), d3 = void 0 === o3 ? 4294967295 : o3 >>> 0;
    if (0 === d3)
      return [];
    if (0 === a3.length)
      return null === tn(s3, a3) ? [a3] : [];
    for (var v3 = 0, p3 = 0, g3 = []; p3 < a3.length; ) {
      s3.lastIndex = rn ? p3 : 0;
      var h3, y3 = tn(s3, rn ? a3 : a3.slice(p3));
      if (null === y3 || (h3 = nn(at(s3.lastIndex + (rn ? 0 : p3)), a3.length)) === v3)
        p3 = Ze(a3, p3, l3);
      else {
        if (g3.push(a3.slice(v3, p3)), g3.length === d3)
          return g3;
        for (var m3 = 1; m3 <= y3.length - 1; m3++)
          if (g3.push(y3[m3]), g3.length === d3)
            return g3;
        p3 = v3 = h3;
      }
    }
    return g3.push(a3.slice(v3)), g3;
  }];
}, !rn);
var on = "	\n\v\f\r \u2028\u2029\uFEFF";
var un = "[" + on + "]";
var an = RegExp("^" + un + un + "*");
var cn = RegExp(un + un + "*$");
var ln = function(t3) {
  return function(e2) {
    var n3 = String(p2(e2));
    return 1 & t3 && (n3 = n3.replace(an, "")), 2 & t3 && (n3 = n3.replace(cn, "")), n3;
  };
};
var fn = { start: ln(1), end: ln(2), trim: ln(3) };
var sn = fn.trim;
It({ target: "String", proto: true, forced: function(t3) {
  return o2(function() {
    return !!on[t3]() || "" != ""[t3]() || on[t3].name !== t3;
  });
}("trim") }, { trim: function() {
  return sn(this);
} });
var dn = de("slice");
var vn = Mt("slice", { ACCESSORS: true, 0: 0, 1: 2 });
var pn = ne("species");
var gn = [].slice;
var hn = Math.max;
It({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t3, e2) {
  var n3, r3, o3, i3 = g2(this), u3 = at(i3.length), a3 = ft(t3, u3), c3 = ft(void 0 === e2 ? u3 : e2, u3);
  if (qt(i3) && ("function" != typeof (n3 = i3.constructor) || n3 !== Array && !qt(n3.prototype) ? h2(n3) && null === (n3 = n3[pn]) && (n3 = void 0) : n3 = void 0, n3 === Array || void 0 === n3))
    return gn.call(i3, a3, c3);
  for (r3 = new (void 0 === n3 ? Array : n3)(hn(c3 - a3, 0)), o3 = 0; a3 < c3; a3++, o3++)
    a3 in i3 && ie(r3, o3, i3[a3]);
  return r3.length = o3, r3;
} });
var yn = Object.keys || function(t3) {
  return pt(t3, gt);
};
var mn = o2(function() {
  yn(1);
});
It({ target: "Object", stat: true, forced: mn }, { keys: function(t3) {
  return yn(Kt(t3));
} });
var Sn;
var xn = function(t3) {
  if (Xe(t3))
    throw TypeError("The method doesn't accept regular expressions");
  return t3;
};
var bn = ne("match");
var En = T2.f;
var wn = "".startsWith;
var On = Math.min;
var Tn = function(t3) {
  var e2 = /./;
  try {
    "/./"[t3](e2);
  } catch (n3) {
    try {
      return e2[bn] = false, "/./"[t3](e2);
    } catch (t4) {
    }
  }
  return false;
}("startsWith");
var An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
function kn(t3) {
  return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
    return typeof t4;
  } : function(t4) {
    return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
  })(t3);
}
It({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t3) {
  var e2 = String(p2(this));
  xn(t3);
  var n3 = at(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r3 = String(t3);
  return wn ? wn.call(e2, r3, n3) : e2.slice(n3, n3 + r3.length) === r3;
} });
var jn = function(t3) {
  return "string" == typeof t3;
};
var Mn = function(t3) {
  return null !== t3 && "object" === kn(t3);
};
var Fn = Array.isArray;
var Vn = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "isWindow", value: function(t4) {
    return t4 === window;
  } }, { key: "addEventListener", value: function(t4, e2, n3) {
    var r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t4 && e2 && n3 && t4.addEventListener(e2, n3, r3);
  } }, { key: "removeEventListener", value: function(t4, e2, n3) {
    var r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t4 && e2 && n3 && t4.removeEventListener(e2, n3, r3);
  } }, { key: "triggerDragEvent", value: function(e2, n3) {
    var r3 = false, o3 = function(t4) {
      var e3;
      null === (e3 = n3.drag) || void 0 === e3 || e3.call(n3, t4);
    }, i3 = function e3(i4) {
      var u3;
      t3.removeEventListener(document, "mousemove", o3), t3.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r3 = false, null === (u3 = n3.end) || void 0 === u3 || u3.call(n3, i4);
    };
    t3.addEventListener(e2, "mousedown", function(e3) {
      var u3;
      r3 || (document.onselectstart = function() {
        return false;
      }, document.ondragstart = function() {
        return false;
      }, t3.addEventListener(document, "mousemove", o3), t3.addEventListener(document, "mouseup", i3), r3 = true, null === (u3 = n3.start) || void 0 === u3 || u3.call(n3, e3));
    });
  } }, { key: "getBoundingClientRect", value: function(t4) {
    return t4 && Mn(t4) && 1 === t4.nodeType ? t4.getBoundingClientRect() : null;
  } }, { key: "hasClass", value: function(t4, e2) {
    return !!(t4 && Mn(t4) && jn(e2) && 1 === t4.nodeType) && t4.classList.contains(e2.trim());
  } }, { key: "addClass", value: function(e2, n3) {
    if (e2 && Mn(e2) && jn(n3) && 1 === e2.nodeType && (n3 = n3.trim(), !t3.hasClass(e2, n3))) {
      var r3 = e2.className;
      e2.className = r3 ? r3 + " " + n3 : n3;
    }
  } }, { key: "removeClass", value: function(t4, e2) {
    if (t4 && Mn(t4) && jn(e2) && 1 === t4.nodeType && "string" == typeof t4.className) {
      e2 = e2.trim();
      for (var n3 = t4.className.trim().split(" "), r3 = n3.length - 1; r3 >= 0; r3--)
        n3[r3] = n3[r3].trim(), n3[r3] && n3[r3] !== e2 || n3.splice(r3, 1);
      t4.className = n3.join(" ");
    }
  } }, { key: "toggleClass", value: function(t4, e2, n3) {
    t4 && Mn(t4) && jn(e2) && 1 === t4.nodeType && t4.classList.toggle(e2, n3);
  } }, { key: "replaceClass", value: function(e2, n3, r3) {
    e2 && Mn(e2) && jn(n3) && jn(r3) && 1 === e2.nodeType && (n3 = n3.trim(), r3 = r3.trim(), t3.removeClass(e2, n3), t3.addClass(e2, r3));
  } }, { key: "getScrollTop", value: function(t4) {
    var e2 = "scrollTop" in t4 ? t4.scrollTop : t4.pageYOffset;
    return Math.max(e2, 0);
  } }, { key: "setScrollTop", value: function(t4, e2) {
    "scrollTop" in t4 ? t4.scrollTop = e2 : t4.scrollTo(t4.scrollX, e2);
  } }, { key: "getRootScrollTop", value: function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } }, { key: "setRootScrollTop", value: function(e2) {
    t3.setScrollTop(window, e2), t3.setScrollTop(document.body, e2);
  } }, { key: "getElementTop", value: function(e2, n3) {
    if (t3.isWindow(e2))
      return 0;
    var r3 = n3 ? t3.getScrollTop(n3) : t3.getRootScrollTop();
    return e2.getBoundingClientRect().top + r3;
  } }, { key: "getVisibleHeight", value: function(e2) {
    return t3.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
  } }, { key: "isHidden", value: function(t4) {
    if (!t4)
      return false;
    var e2 = window.getComputedStyle(t4), n3 = "none" === e2.display, r3 = null === t4.offsetParent && "fixed" !== e2.position;
    return n3 || r3;
  } }, { key: "triggerEvent", value: function(t4, e2) {
    if ("createEvent" in document) {
      var n3 = document.createEvent("HTMLEvents");
      n3.initEvent(e2, false, true), t4.dispatchEvent(n3);
    }
  } }, { key: "calcAngle", value: function(t4, e2) {
    var n3 = t4.getBoundingClientRect(), r3 = n3.left + n3.width / 2, o3 = n3.top + n3.height / 2, i3 = Math.abs(r3 - e2.clientX), u3 = Math.abs(o3 - e2.clientY), a3 = u3 / Math.sqrt(Math.pow(i3, 2) + Math.pow(u3, 2)), c3 = Math.acos(a3), l3 = Math.floor(180 / (Math.PI / c3));
    return e2.clientX > r3 && e2.clientY > o3 && (l3 = 180 - l3), e2.clientX == r3 && e2.clientY > o3 && (l3 = 180), e2.clientX > r3 && e2.clientY == o3 && (l3 = 90), e2.clientX < r3 && e2.clientY > o3 && (l3 = 180 + l3), e2.clientX < r3 && e2.clientY == o3 && (l3 = 270), e2.clientX < r3 && e2.clientY < o3 && (l3 = 360 - l3), l3;
  } }, { key: "querySelector", value: function(t4, e2) {
    return e2 ? e2.querySelector(t4) : document.querySelector(t4);
  } }, { key: "createElement", value: function(t4) {
    for (var e2 = document.createElement(t4), n3 = arguments.length, r3 = new Array(n3 > 1 ? n3 - 1 : 0), o3 = 1; o3 < n3; o3++)
      r3[o3 - 1] = arguments[o3];
    for (var i3 = 0; i3 < r3.length; i3++)
      r3[i3] && e2.classList.add(r3[i3]);
    return e2;
  } }, { key: "appendChild", value: function(t4) {
    for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++)
      t4.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
  } }, { key: "getWindow", value: function(t4) {
    if ("[object Window]" !== t4.toString()) {
      var e2 = t4.ownerDocument;
      return e2 && e2.defaultView || window;
    }
    return t4;
  } }, { key: "isElement", value: function(t4) {
    return t4 instanceof this.getWindow(t4).Element || t4 instanceof Element;
  } }, { key: "isHTMLElement", value: function(t4) {
    return t4 instanceof this.getWindow(t4).HTMLElement || t4 instanceof HTMLElement;
  } }, { key: "isShadowRoot", value: function(t4) {
    return "undefined" != typeof ShadowRoot && (t4 instanceof this.getWindow(t4).ShadowRoot || t4 instanceof ShadowRoot);
  } }, { key: "getWindowScroll", value: function(t4) {
    var e2 = this.getWindow(t4);
    return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
  } }]), t3;
}();
var Kn = Math.floor;
var qn = "".replace;
var Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var Jn = /\$([$&'`]|\d\d?)/g;
var Zn = function(t3, e2, n3, r3, o3, i3) {
  var u3 = n3 + t3.length, a3 = r3.length, c3 = Jn;
  return void 0 !== o3 && (o3 = Kt(o3), c3 = Qn), qn.call(i3, c3, function(i4, c4) {
    var l3;
    switch (c4.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return t3;
      case "`":
        return e2.slice(0, n3);
      case "'":
        return e2.slice(u3);
      case "<":
        l3 = o3[c4.slice(1, -1)];
        break;
      default:
        var f3 = +c4;
        if (0 === f3)
          return i4;
        if (f3 > a3) {
          var s3 = Kn(f3 / 10);
          return 0 === s3 ? i4 : s3 <= a3 ? void 0 === r3[s3 - 1] ? c4.charAt(1) : r3[s3 - 1] + c4.charAt(1) : i4;
        }
        l3 = r3[f3 - 1];
    }
    return void 0 === l3 ? "" : l3;
  });
};
var tr = Math.max;
var er = Math.min;
Ge("replace", 2, function(t3, e2, n3, r3) {
  var o3 = r3.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i3 = r3.REPLACE_KEEPS_$0, u3 = o3 ? "$" : "$0";
  return [function(n4, r4) {
    var o4 = p2(this), i4 = null == n4 ? void 0 : n4[t3];
    return void 0 !== i4 ? i4.call(n4, o4, r4) : e2.call(String(o4), n4, r4);
  }, function(t4, r4) {
    if (!o3 && i3 || "string" == typeof r4 && -1 === r4.indexOf(u3)) {
      var a3 = n3(e2, t4, this, r4);
      if (a3.done)
        return a3.value;
    }
    var c3 = A2(t4), l3 = String(this), f3 = "function" == typeof r4;
    f3 || (r4 = String(r4));
    var s3 = c3.global;
    if (s3) {
      var d3 = c3.unicode;
      c3.lastIndex = 0;
    }
    for (var v3 = []; ; ) {
      var p3 = tn(c3, l3);
      if (null === p3)
        break;
      if (v3.push(p3), !s3)
        break;
      "" === String(p3[0]) && (c3.lastIndex = Ze(l3, at(c3.lastIndex), d3));
    }
    for (var g3, h3 = "", y3 = 0, m3 = 0; m3 < v3.length; m3++) {
      p3 = v3[m3];
      for (var S3 = String(p3[0]), x3 = tr(er(it(p3.index), l3.length), 0), b3 = [], E4 = 1; E4 < p3.length; E4++)
        b3.push(void 0 === (g3 = p3[E4]) ? g3 : String(g3));
      var w4 = p3.groups;
      if (f3) {
        var O3 = [S3].concat(b3, x3, l3);
        void 0 !== w4 && O3.push(w4);
        var T3 = String(r4.apply(void 0, O3));
      } else
        T3 = Zn(S3, l3, x3, b3, w4, r4);
      x3 >= y3 && (h3 += l3.slice(y3, x3) + T3, y3 = x3 + S3.length);
    }
    return h3 + l3.slice(y3);
  }];
});
var nr = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "camelize", value: function(t4) {
    return t4.replace(/-(\w)/g, function(t5, e2) {
      return e2 ? e2.toUpperCase() : "";
    });
  } }, { key: "capitalize", value: function(t4) {
    return t4.charAt(0).toUpperCase() + t4.slice(1);
  } }]), t3;
}();
var rr = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "_clone", value: function() {
  } }]), t3;
}();
var or = ne("isConcatSpreadable");
var ir = fe >= 51 || !o2(function() {
  var t3 = [];
  return t3[or] = false, t3.concat()[0] !== t3;
});
var ur = de("concat");
var ar = function(t3) {
  if (!h2(t3))
    return false;
  var e2 = t3[or];
  return void 0 !== e2 ? !!e2 : qt(t3);
};
It({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t3) {
  var e2, n3, r3, o3, i3, u3 = Kt(this), a3 = oe(u3, 0), c3 = 0;
  for (e2 = -1, r3 = arguments.length; e2 < r3; e2++)
    if (ar(i3 = -1 === e2 ? u3 : arguments[e2])) {
      if (c3 + (o3 = at(i3.length)) > 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      for (n3 = 0; n3 < o3; n3++, c3++)
        n3 in i3 && ie(a3, c3, i3[n3]);
    } else {
      if (c3 >= 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      ie(a3, c3++, i3);
    }
  return a3.length = c3, a3;
} });
var cr;
var lr = function(t3, e2, n3) {
  if (Ve(t3), void 0 === e2)
    return t3;
  switch (n3) {
    case 0:
      return function() {
        return t3.call(e2);
      };
    case 1:
      return function(n4) {
        return t3.call(e2, n4);
      };
    case 2:
      return function(n4, r3) {
        return t3.call(e2, n4, r3);
      };
    case 3:
      return function(n4, r3, o3) {
        return t3.call(e2, n4, r3, o3);
      };
  }
  return function() {
    return t3.apply(e2, arguments);
  };
};
var fr = [].push;
var sr = function(t3) {
  var e2 = 1 == t3, n3 = 2 == t3, r3 = 3 == t3, o3 = 4 == t3, i3 = 6 == t3, u3 = 7 == t3, a3 = 5 == t3 || i3;
  return function(c3, l3, f3, s3) {
    for (var d3, p3, g3 = Kt(c3), h3 = v2(g3), y3 = lr(l3, f3, 3), m3 = at(h3.length), S3 = 0, x3 = s3 || oe, b3 = e2 ? x3(c3, m3) : n3 || u3 ? x3(c3, 0) : void 0; m3 > S3; S3++)
      if ((a3 || S3 in h3) && (p3 = y3(d3 = h3[S3], S3, g3), t3))
        if (e2)
          b3[S3] = p3;
        else if (p3)
          switch (t3) {
            case 3:
              return true;
            case 5:
              return d3;
            case 6:
              return S3;
            case 2:
              fr.call(b3, d3);
          }
        else
          switch (t3) {
            case 4:
              return false;
            case 7:
              fr.call(b3, d3);
          }
    return i3 ? -1 : r3 || o3 ? o3 : b3;
  };
};
var dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) };
var vr = i2 ? Object.defineProperties : function(t3, e2) {
  A2(t3);
  for (var n3, r3 = yn(e2), o3 = r3.length, i3 = 0; o3 > i3; )
    R2.f(t3, n3 = r3[i3++], e2[n3]);
  return t3;
};
var pr = nt("document", "documentElement");
var gr = Y2("IE_PROTO");
var hr = function() {
};
var yr = function(t3) {
  return "<script>" + t3 + "<\/script>";
};
var mr = function() {
  try {
    cr = document.domain && new ActiveXObject("htmlfile");
  } catch (t4) {
  }
  var t3, e2;
  mr = cr ? function(t4) {
    t4.write(yr("")), t4.close();
    var e3 = t4.parentWindow.Object;
    return t4 = null, e3;
  }(cr) : ((e2 = E2("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t3 = e2.contentWindow.document).open(), t3.write(yr("document.F=Object")), t3.close(), t3.F);
  for (var n3 = gt.length; n3--; )
    delete mr.prototype[gt[n3]];
  return mr();
};
G[gr] = true;
var Sr = Object.create || function(t3, e2) {
  var n3;
  return null !== t3 ? (hr.prototype = A2(t3), n3 = new hr(), hr.prototype = null, n3[gr] = t3) : n3 = mr(), void 0 === e2 ? n3 : vr(n3, e2);
};
var xr = ne("unscopables");
var br = Array.prototype;
null == br[xr] && R2.f(br, xr, { configurable: true, value: Sr(null) });
var Er = function(t3) {
  br[xr][t3] = true;
};
var wr = dr.find;
var Or = true;
var Tr = Mt("find");
"find" in [] && Array(1).find(function() {
  Or = false;
}), It({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t3) {
  return wr(this, t3, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("find");
var Ar = dr.findIndex;
var kr = true;
var Rr = Mt("findIndex");
"findIndex" in [] && Array(1).findIndex(function() {
  kr = false;
}), It({ target: "Array", proto: true, forced: kr || !Rr }, { findIndex: function(t3) {
  return Ar(this, t3, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("findIndex");
var Ir = function(t3, e2, n3, r3, o3, i3, u3, a3) {
  for (var c3, l3 = o3, f3 = 0, s3 = !!u3 && lr(u3, a3, 3); f3 < r3; ) {
    if (f3 in n3) {
      if (c3 = s3 ? s3(n3[f3], f3, e2) : n3[f3], i3 > 0 && qt(c3))
        l3 = Ir(t3, e2, c3, at(c3.length), l3, i3 - 1) - 1;
      else {
        if (l3 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        t3[l3] = c3;
      }
      l3++;
    }
    f3++;
  }
  return l3;
};
var jr = Ir;
It({ target: "Array", proto: true }, { flat: function() {
  var t3 = arguments.length ? arguments[0] : void 0, e2 = Kt(this), n3 = at(e2.length), r3 = oe(e2, 0);
  return r3.length = jr(r3, e2, e2, n3, 0, void 0 === t3 ? 1 : it(t3)), r3;
} });
var Cr = function(t3) {
  var e2 = t3.return;
  if (void 0 !== e2)
    return A2(e2.call(t3)).value;
};
var Lr = function(t3, e2, n3, r3) {
  try {
    return r3 ? e2(A2(n3)[0], n3[1]) : e2(n3);
  } catch (e3) {
    throw Cr(t3), e3;
  }
};
var Pr = {};
var Mr = ne("iterator");
var _r = Array.prototype;
var Dr = function(t3) {
  return void 0 !== t3 && (Pr.Array === t3 || _r[Mr] === t3);
};
var Ur = ne("iterator");
var Nr = function(t3) {
  if (null != t3)
    return t3[Ur] || t3["@@iterator"] || Pr[be(t3)];
};
var Fr = ne("iterator");
var Wr = false;
try {
  zr = 0, $r = { next: function() {
    return { done: !!zr++ };
  }, return: function() {
    Wr = true;
  } };
  $r[Fr] = function() {
    return this;
  }, Array.from($r, function() {
    throw 2;
  });
} catch (t3) {
}
var zr;
var $r;
var Br = function(t3, e2) {
  if (!e2 && !Wr)
    return false;
  var n3 = false;
  try {
    var r3 = {};
    r3[Fr] = function() {
      return { next: function() {
        return { done: n3 = true };
      } };
    }, t3(r3);
  } catch (t4) {
  }
  return n3;
};
var Yr = !Br(function(t3) {
  Array.from(t3);
});
It({ target: "Array", stat: true, forced: Yr }, { from: function(t3) {
  var e2, n3, r3, o3, i3, u3, a3 = Kt(t3), c3 = "function" == typeof this ? this : Array, l3 = arguments.length, f3 = l3 > 1 ? arguments[1] : void 0, s3 = void 0 !== f3, d3 = Nr(a3), v3 = 0;
  if (s3 && (f3 = lr(f3, l3 > 2 ? arguments[2] : void 0, 2)), null == d3 || c3 == Array && Dr(d3))
    for (n3 = new c3(e2 = at(a3.length)); e2 > v3; v3++)
      u3 = s3 ? f3(a3[v3], v3) : a3[v3], ie(n3, v3, u3);
  else
    for (i3 = (o3 = d3.call(a3)).next, n3 = new c3(); !(r3 = i3.call(o3)).done; v3++)
      u3 = s3 ? Lr(o3, f3, [r3.value, v3], true) : r3.value, ie(n3, v3, u3);
  return n3.length = v3, n3;
} });
var Gr = function(t3) {
  return function(e2, n3, r3, o3) {
    Ve(n3);
    var i3 = Kt(e2), u3 = v2(i3), a3 = at(i3.length), c3 = t3 ? a3 - 1 : 0, l3 = t3 ? -1 : 1;
    if (r3 < 2)
      for (; ; ) {
        if (c3 in u3) {
          o3 = u3[c3], c3 += l3;
          break;
        }
        if (c3 += l3, t3 ? c3 < 0 : a3 <= c3)
          throw TypeError("Reduce of empty array with no initial value");
      }
    for (; t3 ? c3 >= 0 : a3 > c3; c3 += l3)
      c3 in u3 && (o3 = n3(o3, u3[c3], c3, i3));
    return o3;
  };
};
var Hr = { left: Gr(false), right: Gr(true) };
var Xr = "process" == s2(r2.process);
var Vr = Hr.left;
var Kr = jt("reduce");
var qr = Mt("reduce", { 1: 0 });
It({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe > 79 && fe < 83 }, { reduce: function(t3) {
  return Vr(this, t3, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("flat");
var Qr;
var Jr;
var Zr;
var to = !o2(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var eo = e(function(t3) {
  var e2 = R2.f, n3 = $2("meta"), r3 = 0, o3 = Object.isExtensible || function() {
    return true;
  }, i3 = function(t4) {
    e2(t4, n3, { value: { objectID: "O" + ++r3, weakData: {} } });
  }, u3 = t3.exports = { REQUIRED: false, fastKey: function(t4, e3) {
    if (!h2(t4))
      return "symbol" == typeof t4 ? t4 : ("string" == typeof t4 ? "S" : "P") + t4;
    if (!S2(t4, n3)) {
      if (!o3(t4))
        return "F";
      if (!e3)
        return "E";
      i3(t4);
    }
    return t4[n3].objectID;
  }, getWeakData: function(t4, e3) {
    if (!S2(t4, n3)) {
      if (!o3(t4))
        return true;
      if (!e3)
        return false;
      i3(t4);
    }
    return t4[n3].weakData;
  }, onFreeze: function(t4) {
    return to && u3.REQUIRED && o3(t4) && !S2(t4, n3) && i3(t4), t4;
  } };
  G[n3] = true;
});
var no = function(t3, e2) {
  this.stopped = t3, this.result = e2;
};
var ro = function(t3, e2, n3) {
  var r3, o3, i3, u3, a3, c3, l3, f3 = n3 && n3.that, s3 = !(!n3 || !n3.AS_ENTRIES), d3 = !(!n3 || !n3.IS_ITERATOR), v3 = !(!n3 || !n3.INTERRUPTED), p3 = lr(e2, f3, 1 + s3 + v3), g3 = function(t4) {
    return r3 && Cr(r3), new no(true, t4);
  }, h3 = function(t4) {
    return s3 ? (A2(t4), v3 ? p3(t4[0], t4[1], g3) : p3(t4[0], t4[1])) : v3 ? p3(t4, g3) : p3(t4);
  };
  if (d3)
    r3 = t3;
  else {
    if ("function" != typeof (o3 = Nr(t3)))
      throw TypeError("Target is not iterable");
    if (Dr(o3)) {
      for (i3 = 0, u3 = at(t3.length); u3 > i3; i3++)
        if ((a3 = h3(t3[i3])) && a3 instanceof no)
          return a3;
      return new no(false);
    }
    r3 = o3.call(t3);
  }
  for (c3 = r3.next; !(l3 = c3.call(r3)).done; ) {
    try {
      a3 = h3(l3.value);
    } catch (t4) {
      throw Cr(r3), t4;
    }
    if ("object" == typeof a3 && a3 && a3 instanceof no)
      return a3;
  }
  return new no(false);
};
var oo = function(t3, e2, n3) {
  if (!(t3 instanceof e2))
    throw TypeError("Incorrect " + (n3 ? n3 + " " : "") + "invocation");
  return t3;
};
var io = R2.f;
var uo = ne("toStringTag");
var ao = function(t3, e2, n3) {
  t3 && !S2(t3 = n3 ? t3 : t3.prototype, uo) && io(t3, uo, { configurable: true, value: e2 });
};
var co = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t3, e2 = false, n3 = {};
  try {
    (t3 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n3, []), e2 = n3 instanceof Array;
  } catch (t4) {
  }
  return function(n4, r3) {
    return A2(n4), function(t4) {
      if (!h2(t4) && null !== t4)
        throw TypeError("Can't set " + String(t4) + " as a prototype");
    }(r3), e2 ? t3.call(n4, r3) : n4.__proto__ = r3, n4;
  };
}() : void 0);
var lo = function(t3, e2, n3) {
  for (var r3 in e2)
    Z(t3, r3, e2[r3], n3);
  return t3;
};
var fo = !o2(function() {
  function t3() {
  }
  return t3.prototype.constructor = null, Object.getPrototypeOf(new t3()) !== t3.prototype;
});
var so = Y2("IE_PROTO");
var vo = Object.prototype;
var po = fo ? Object.getPrototypeOf : function(t3) {
  return t3 = Kt(t3), S2(t3, so) ? t3[so] : "function" == typeof t3.constructor && t3 instanceof t3.constructor ? t3.constructor.prototype : t3 instanceof Object ? vo : null;
};
var go = ne("iterator");
var ho = false;
[].keys && ("next" in (Zr = [].keys()) ? (Jr = po(po(Zr))) !== Object.prototype && (Qr = Jr) : ho = true), (null == Qr || o2(function() {
  var t3 = {};
  return Qr[go].call(t3) !== t3;
})) && (Qr = {}), S2(Qr, go) || I2(Qr, go, function() {
  return this;
});
var yo = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho };
var mo = yo.IteratorPrototype;
var So = function() {
  return this;
};
var xo = yo.IteratorPrototype;
var bo = yo.BUGGY_SAFARI_ITERATORS;
var Eo = ne("iterator");
var wo = function() {
  return this;
};
var Oo = function(t3, e2, n3, r3, o3, i3, u3) {
  !function(t4, e3, n4) {
    var r4 = e3 + " Iterator";
    t4.prototype = Sr(mo, { next: l2(1, n4) }), ao(t4, r4, false), Pr[r4] = So;
  }(n3, e2, r3);
  var a3, c3, f3, s3 = function(t4) {
    if (t4 === o3 && h3)
      return h3;
    if (!bo && t4 in p3)
      return p3[t4];
    switch (t4) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n3(this, t4);
        };
    }
    return function() {
      return new n3(this);
    };
  }, d3 = e2 + " Iterator", v3 = false, p3 = t3.prototype, g3 = p3[Eo] || p3["@@iterator"] || o3 && p3[o3], h3 = !bo && g3 || s3(o3), y3 = "Array" == e2 && p3.entries || g3;
  if (y3 && (a3 = po(y3.call(new t3())), xo !== Object.prototype && a3.next && (po(a3) !== xo && (co ? co(a3, xo) : "function" != typeof a3[Eo] && I2(a3, Eo, wo)), ao(a3, d3, true))), "values" == o3 && g3 && "values" !== g3.name && (v3 = true, h3 = function() {
    return g3.call(this);
  }), p3[Eo] !== h3 && I2(p3, Eo, h3), Pr[e2] = h3, o3)
    if (c3 = { values: s3("values"), keys: i3 ? h3 : s3("keys"), entries: s3("entries") }, u3)
      for (f3 in c3)
        (bo || v3 || !(f3 in p3)) && Z(p3, f3, c3[f3]);
    else
      It({ target: e2, proto: true, forced: bo || v3 }, c3);
  return c3;
};
var To = ne("species");
var Ao = R2.f;
var ko = eo.fastKey;
var Ro = J2.set;
var Io = J2.getterFor;
!function(t3, e2, n3) {
  var i3 = -1 !== t3.indexOf("Map"), u3 = -1 !== t3.indexOf("Weak"), a3 = i3 ? "set" : "add", c3 = r2[t3], l3 = c3 && c3.prototype, f3 = c3, s3 = {}, d3 = function(t4) {
    var e3 = l3[t4];
    Z(l3, t4, "add" == t4 ? function(t5) {
      return e3.call(this, 0 === t5 ? 0 : t5), this;
    } : "delete" == t4 ? function(t5) {
      return !(u3 && !h2(t5)) && e3.call(this, 0 === t5 ? 0 : t5);
    } : "get" == t4 ? function(t5) {
      return u3 && !h2(t5) ? void 0 : e3.call(this, 0 === t5 ? 0 : t5);
    } : "has" == t4 ? function(t5) {
      return !(u3 && !h2(t5)) && e3.call(this, 0 === t5 ? 0 : t5);
    } : function(t5, n4) {
      return e3.call(this, 0 === t5 ? 0 : t5, n4), this;
    });
  };
  if (kt(t3, "function" != typeof c3 || !(u3 || l3.forEach && !o2(function() {
    new c3().entries().next();
  }))))
    f3 = n3.getConstructor(e2, t3, i3, a3), eo.REQUIRED = true;
  else if (kt(t3, true)) {
    var v3 = new f3(), p3 = v3[a3](u3 ? {} : -0, 1) != v3, g3 = o2(function() {
      v3.has(1);
    }), y3 = Br(function(t4) {
      new c3(t4);
    }), m3 = !u3 && o2(function() {
      for (var t4 = new c3(), e3 = 5; e3--; )
        t4[a3](e3, e3);
      return !t4.has(-0);
    });
    y3 || ((f3 = e2(function(e3, n4) {
      oo(e3, f3, t3);
      var r3 = function(t4, e4, n5) {
        var r4, o3;
        return co && "function" == typeof (r4 = e4.constructor) && r4 !== n5 && h2(o3 = r4.prototype) && o3 !== n5.prototype && co(t4, o3), t4;
      }(new c3(), e3, f3);
      return null != n4 && ro(n4, r3[a3], { that: r3, AS_ENTRIES: i3 }), r3;
    })).prototype = l3, l3.constructor = f3), (g3 || m3) && (d3("delete"), d3("has"), i3 && d3("get")), (m3 || p3) && d3(a3), u3 && l3.clear && delete l3.clear;
  }
  s3[t3] = f3, It({ global: true, forced: f3 != c3 }, s3), ao(f3, t3), u3 || n3.setStrong(f3, t3, i3);
}("Set", function(t3) {
  return function() {
    return t3(this, arguments.length ? arguments[0] : void 0);
  };
}, { getConstructor: function(t3, e2, n3, r3) {
  var o3 = t3(function(t4, u4) {
    oo(t4, o3, e2), Ro(t4, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i2 || (t4.size = 0), null != u4 && ro(u4, t4[r3], { that: t4, AS_ENTRIES: n3 });
  }), u3 = Io(e2), a3 = function(t4, e3, n4) {
    var r4, o4, a4 = u3(t4), l3 = c3(t4, e3);
    return l3 ? l3.value = n4 : (a4.last = l3 = { index: o4 = ko(e3, true), key: e3, value: n4, previous: r4 = a4.last, next: void 0, removed: false }, a4.first || (a4.first = l3), r4 && (r4.next = l3), i2 ? a4.size++ : t4.size++, "F" !== o4 && (a4.index[o4] = l3)), t4;
  }, c3 = function(t4, e3) {
    var n4, r4 = u3(t4), o4 = ko(e3);
    if ("F" !== o4)
      return r4.index[o4];
    for (n4 = r4.first; n4; n4 = n4.next)
      if (n4.key == e3)
        return n4;
  };
  return lo(o3.prototype, { clear: function() {
    for (var t4 = u3(this), e3 = t4.index, n4 = t4.first; n4; )
      n4.removed = true, n4.previous && (n4.previous = n4.previous.next = void 0), delete e3[n4.index], n4 = n4.next;
    t4.first = t4.last = void 0, i2 ? t4.size = 0 : this.size = 0;
  }, delete: function(t4) {
    var e3 = this, n4 = u3(e3), r4 = c3(e3, t4);
    if (r4) {
      var o4 = r4.next, a4 = r4.previous;
      delete n4.index[r4.index], r4.removed = true, a4 && (a4.next = o4), o4 && (o4.previous = a4), n4.first == r4 && (n4.first = o4), n4.last == r4 && (n4.last = a4), i2 ? n4.size-- : e3.size--;
    }
    return !!r4;
  }, forEach: function(t4) {
    for (var e3, n4 = u3(this), r4 = lr(t4, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n4.first; )
      for (r4(e3.value, e3.key, this); e3 && e3.removed; )
        e3 = e3.previous;
  }, has: function(t4) {
    return !!c3(this, t4);
  } }), lo(o3.prototype, n3 ? { get: function(t4) {
    var e3 = c3(this, t4);
    return e3 && e3.value;
  }, set: function(t4, e3) {
    return a3(this, 0 === t4 ? 0 : t4, e3);
  } } : { add: function(t4) {
    return a3(this, t4 = 0 === t4 ? 0 : t4, t4);
  } }), i2 && Ao(o3.prototype, "size", { get: function() {
    return u3(this).size;
  } }), o3;
}, setStrong: function(t3, e2, n3) {
  var r3 = e2 + " Iterator", o3 = Io(e2), u3 = Io(r3);
  Oo(t3, e2, function(t4, e3) {
    Ro(this, { type: r3, target: t4, state: o3(t4), kind: e3, last: void 0 });
  }, function() {
    for (var t4 = u3(this), e3 = t4.kind, n4 = t4.last; n4 && n4.removed; )
      n4 = n4.previous;
    return t4.target && (t4.last = n4 = n4 ? n4.next : t4.state.first) ? "keys" == e3 ? { value: n4.key, done: false } : "values" == e3 ? { value: n4.value, done: false } : { value: [n4.key, n4.value], done: false } : (t4.target = void 0, { value: void 0, done: true });
  }, n3 ? "entries" : "values", !n3, true), function(t4) {
    var e3 = nt(t4), n4 = R2.f;
    i2 && e3 && !e3[To] && n4(e3, To, { configurable: true, get: function() {
      return this;
    } });
  }(e2);
} });
var jo = Qe.charAt;
var Co = J2.set;
var Lo = J2.getterFor("String Iterator");
Oo(String, "String", function(t3) {
  Co(this, { type: "String Iterator", string: String(t3), index: 0 });
}, function() {
  var t3, e2 = Lo(this), n3 = e2.string, r3 = e2.index;
  return r3 >= n3.length ? { value: void 0, done: true } : (t3 = jo(n3, r3), e2.index += t3.length, { value: t3, done: false });
});
var Po = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
var Mo = J2.set;
var _o = J2.getterFor("Array Iterator");
var Do = Oo(Array, "Array", function(t3, e2) {
  Mo(this, { type: "Array Iterator", target: g2(t3), index: 0, kind: e2 });
}, function() {
  var t3 = _o(this), e2 = t3.target, n3 = t3.kind, r3 = t3.index++;
  return !e2 || r3 >= e2.length ? (t3.target = void 0, { value: void 0, done: true }) : "keys" == n3 ? { value: r3, done: false } : "values" == n3 ? { value: e2[r3], done: false } : { value: [r3, e2[r3]], done: false };
}, "values");
Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
var Uo = ne("iterator");
var No = ne("toStringTag");
var Fo = Do.values;
for (Wo in Po) {
  zo = r2[Wo], $o2 = zo && zo.prototype;
  if ($o2) {
    if ($o2[Uo] !== Fo)
      try {
        I2($o2, Uo, Fo);
      } catch (t3) {
        $o2[Uo] = Fo;
      }
    if ($o2[No] || I2($o2, No, Wo), Po[Wo]) {
      for (Bo2 in Do)
        if ($o2[Bo2] !== Do[Bo2])
          try {
            I2($o2, Bo2, Do[Bo2]);
          } catch (t3) {
            $o2[Bo2] = Do[Bo2];
          }
    }
  }
}
var zo;
var $o2;
var Bo2;
var Wo;
var Yo = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "deduplicate", value: function(t4) {
    return Array.from(new Set(t4));
  } }, { key: "flat", value: function(e2) {
    return e2.reduce(function(e3, n3) {
      var r3 = Array.isArray(n3) ? t3.flat(n3) : n3;
      return e3.concat(r3);
    }, []);
  } }, { key: "find", value: function(t4, e2) {
    return t4.find(e2);
  } }, { key: "findIndex", value: function(t4, e2) {
    return t4.findIndex(e2);
  } }]), t3;
}();
var Go = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "today", value: function() {
    return /* @__PURE__ */ new Date();
  } }]), t3;
}();
var Vo = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "range", value: function(t4, e2, n3) {
    return Math.min(Math.max(t4, e2), n3);
  } }, { key: "clamp", value: function(t4, e2, n3) {
    return e2 < n3 ? t4 < e2 ? e2 : t4 > n3 ? n3 : t4 : t4 < n3 ? n3 : t4 > e2 ? e2 : t4;
  } }]), t3;
}();

// node_modules/vue3-angle/vue3-angle.es.js
var calcAngle = (element, event) => {
  const rect = element.getBoundingClientRect();
  const originX = rect.left + rect.width / 2;
  const originY = rect.top + rect.height / 2;
  const x3 = Math.abs(originX - event.clientX);
  const y3 = Math.abs(originY - event.clientY);
  const z3 = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
  const cos = y3 / z3;
  const rad = Math.acos(cos);
  let angle = Math.floor(180 / (Math.PI / rad));
  if (event.clientX > originX && event.clientY > originY) {
    angle = 180 - angle;
  }
  if (event.clientX == originX && event.clientY > originY) {
    angle = 180;
  }
  if (event.clientX > originX && event.clientY == originY) {
    angle = 90;
  }
  if (event.clientX < originX && event.clientY > originY) {
    angle = 180 + angle;
  }
  if (event.clientX < originX && event.clientY == originY) {
    angle = 270;
  }
  if (event.clientX < originX && event.clientY < originY) {
    angle = 360 - angle;
  }
  return angle;
};
var isDragging = false;
var triggerDragEvent = (element, options) => {
  const moveFn = function(event) {
    var _a;
    (_a = options.drag) == null ? void 0 : _a.call(options, event);
  };
  const upFn = function(event) {
    var _a;
    document.removeEventListener("mousemove", moveFn, false);
    document.removeEventListener("mouseup", upFn, false);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    (_a = options.end) == null ? void 0 : _a.call(options, event);
  };
  if (element) {
    element.addEventListener("mousedown", (event) => {
      var _a;
      if (isDragging)
        return;
      document.onselectstart = () => false;
      document.ondragstart = () => false;
      document.addEventListener("mousemove", moveFn, false);
      document.addEventListener("mouseup", upFn, false);
      isDragging = true;
      (_a = options.start) == null ? void 0 : _a.call(options, event);
    });
  }
  return;
};
var angleProps = {
  angle: {
    type: Number,
    default: 0
  },
  size: {
    type: Number,
    default: 16,
    validator: (value) => {
      return value >= 16;
    }
  },
  borderWidth: {
    type: Number,
    default: 1,
    validator: (value) => {
      return value >= 1;
    }
  },
  borderColor: {
    type: String,
    default: "#666"
  }
};
var Angle = defineComponent({
  name: "Angle",
  props: angleProps,
  emits: ["update:angle", "change"],
  setup(props, {
    emit
  }) {
    const angleRef = ref(null);
    const rotate = ref(props.angle);
    watch(() => props.angle, (angle) => {
      rotate.value = angle;
    });
    const updateAngle = () => {
      let value = Number(rotate.value);
      if (!isNaN(value)) {
        value = value > 360 || value < 0 ? props.angle : value;
        rotate.value = value === 360 ? 0 : value;
        emit("update:angle", rotate.value);
        emit("change", rotate.value);
      }
    };
    const getStyle = computed(() => {
      return {
        width: props.size + "px",
        height: props.size + "px",
        borderWidth: props.borderWidth + "px",
        borderColor: props.borderColor,
        transform: `rotate(${rotate.value}deg)`
      };
    });
    const handleDrag = (event) => {
      if (angleRef.value) {
        rotate.value = calcAngle(angleRef.value, event) % 360;
        updateAngle();
      }
    };
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      if (angleRef.value) {
        triggerDragEvent(angleRef.value, dragConfig);
      }
    });
    return () => {
      return createVNode("div", {
        "class": "bee-angle"
      }, [createVNode("div", {
        "class": "bee-angle__round",
        "ref": angleRef,
        "style": getStyle.value
      }, null)]);
    };
  }
});

// node_modules/vue3-colorpicker/index.es.js
import "/var/www/html/crm_original/node_modules/vue3-angle/style.css";

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x3 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x3 + width,
    bottom: y3 + height,
    left: x3,
    x: x3,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v3 = within(min2, value, max2);
  return v3 > max2 ? max2 : v3;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x3 = _ref.x, y3 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x3 * dpr) / dpr || 0,
    y: round(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x3,
    y: y3
  }) : {
    x: x3,
    y: y3
  };
  x3 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x3 -= offsetX - popperRect.width;
      x3 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x3,
    y: y3
  }) : {
    x: x3,
    y: y3
  };
  x3 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y3 + "px)" : "translate3d(" + x3 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x3 = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3 + getWindowScrollBarX(element),
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x3 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b3) {
    return overflows[a3] - overflows[b3];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x3 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x3;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p3, c3) {
    return p3.replace(/%s/, c3);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s3) {
            return '"' + s3 + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn3) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn3(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/vue3-colorpicker/index.es.js
var import_gradient_parser = __toESM(require_node());
var Oe2 = Object.defineProperty;
var ze2 = (e2, o3, t3) => o3 in e2 ? Oe2(e2, o3, { enumerable: true, configurable: true, writable: true, value: t3 }) : e2[o3] = t3;
var E3 = (e2, o3, t3) => (ze2(e2, typeof o3 != "symbol" ? o3 + "" : o3, t3), t3);
var B3 = (e2) => Math.round(e2 * 100) / 100;
var w3 = class {
  constructor(o3) {
    E3(this, "instance");
    E3(this, "alphaValue", 0);
    E3(this, "redValue", 0);
    E3(this, "greenValue", 0);
    E3(this, "blueValue", 0);
    E3(this, "hueValue", 0);
    E3(this, "saturationValue", 0);
    E3(this, "brightnessValue", 0);
    E3(this, "hslSaturationValue", 0);
    E3(this, "lightnessValue", 0);
    E3(this, "initAlpha", () => {
      const o4 = this.instance.getAlpha();
      this.alphaValue = Math.min(1, o4) * 100;
    });
    E3(this, "initLightness", () => {
      const { s: o4, l: t3 } = this.instance.toHsl();
      this.hslSaturationValue = B3(o4), this.lightnessValue = B3(t3);
    });
    E3(this, "initRgb", () => {
      const { r: o4, g: t3, b: n3 } = this.instance.toRgb();
      this.redValue = B3(o4), this.greenValue = B3(t3), this.blueValue = B3(n3);
    });
    E3(this, "initHsb", () => {
      const { h: o4, s: t3, v: n3 } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(o4)), this.saturationValue = B3(t3), this.brightnessValue = B3(n3);
    });
    E3(this, "toHexString", () => this.instance.toHexString());
    E3(this, "toRgbString", () => this.instance.toRgbString());
    this.instance = tinycolor(o3), this.initRgb(), this.initHsb(), this.initLightness(), this.initAlpha();
  }
  toString(o3) {
    return this.instance.toString(o3);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(o3) {
    this.instance = tinycolor(o3), this.initHsb(), this.initRgb(), this.initAlpha(), this.initLightness();
  }
  // 
  set hue(o3) {
    this.saturation === 0 && this.brightness === 0 && (this.saturationValue = 1, this.brightnessValue = 1), this.instance = tinycolor({
      h: B3(o3),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.hueValue = B3(o3);
  }
  get hue() {
    return this.hueValue;
  }
  // 
  set saturation(o3) {
    this.instance = tinycolor({
      h: this.hue,
      s: B3(o3),
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.saturationValue = B3(o3);
  }
  get saturation() {
    return this.saturationValue;
  }
  // 
  set brightness(o3) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.saturation,
      v: B3(o3),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.brightnessValue = B3(o3);
  }
  get brightness() {
    return this.brightnessValue;
  }
  // 
  set lightness(o3) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.hslSaturationValue,
      l: B3(o3),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initHsb(), this.lightnessValue = B3(o3);
  }
  get lightness() {
    return this.lightnessValue;
  }
  // red
  set red(o3) {
    const t3 = this.instance.toRgb();
    this.instance = tinycolor({
      ...t3,
      r: B3(o3),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.redValue = B3(o3);
  }
  get red() {
    return this.redValue;
  }
  // green
  set green(o3) {
    const t3 = this.instance.toRgb();
    this.instance = tinycolor({
      ...t3,
      g: B3(o3),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.greenValue = B3(o3);
  }
  get green() {
    return this.greenValue;
  }
  // blue
  set blue(o3) {
    const t3 = this.instance.toRgb();
    this.instance = tinycolor({
      ...t3,
      b: B3(o3),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.blueValue = B3(o3);
  }
  get blue() {
    return this.blueValue;
  }
  // alpha
  set alpha(o3) {
    this.instance.setAlpha(o3 / 100), this.alphaValue = o3;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, this.alpha / 100];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, this.alpha / 100];
  }
  get HSL() {
    return [this.hue, this.hslSaturationValue, this.lightness, this.alpha / 100];
  }
};
function $e2(e2, o3, t3, n3) {
  return `rgba(${[e2, o3, t3, n3 / 100].join(",")})`;
}
var re2 = (e2, o3, t3) => o3 < t3 ? e2 < o3 ? o3 : e2 > t3 ? t3 : e2 : e2 < t3 ? t3 : e2 > o3 ? o3 : e2;
var ie2 = "color-history";
var ce2 = 8;
var G2 = (e2, o3) => {
  const t3 = e2.__vccOpts || e2;
  for (const [n3, l3] of o3)
    t3[n3] = l3;
  return t3;
};
var Je2 = defineComponent({
  name: "Alpha",
  props: {
    color: C.instanceOf(w3),
    size: C.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(e2, { emit: o3 }) {
    const t3 = ref(null), n3 = ref(null);
    let l3 = e2.color || new w3();
    const r3 = reactive({
      red: l3.red,
      green: l3.green,
      blue: l3.blue,
      alpha: l3.alpha
    });
    watch(
      () => e2.color,
      (s3) => {
        s3 && (l3 = s3, merge_default(r3, {
          red: s3.red,
          green: s3.green,
          blue: s3.blue,
          alpha: s3.alpha
        }));
      },
      { deep: true }
    );
    const c3 = computed(() => {
      const s3 = $e2(r3.red, r3.green, r3.blue, 0), y3 = $e2(r3.red, r3.green, r3.blue, 100);
      return {
        background: `linear-gradient(to right, ${s3} , ${y3})`
      };
    }), a3 = () => {
      if (t3.value && n3.value) {
        const s3 = r3.alpha / 100, y3 = t3.value.getBoundingClientRect(), m3 = n3.value.offsetWidth;
        return Math.round(s3 * (y3.width - m3) + m3 / 2);
      }
      return 0;
    }, h3 = computed(() => ({
      left: a3() + "px",
      top: 0
    })), _3 = (s3) => {
      s3.target !== t3.value && p3(s3);
    }, p3 = (s3) => {
      if (s3.stopPropagation(), t3.value && n3.value) {
        const y3 = t3.value.getBoundingClientRect(), m3 = n3.value.offsetWidth;
        let C3 = s3.clientX - y3.left;
        C3 = Math.max(m3 / 2, C3), C3 = Math.min(C3, y3.width - m3 / 2);
        const g3 = Math.round((C3 - m3 / 2) / (y3.width - m3) * 100);
        l3.alpha = g3, r3.alpha = g3, o3("change", g3);
      }
    };
    return tryOnMounted(() => {
      const s3 = {
        drag: (y3) => {
          p3(y3);
        },
        end: (y3) => {
          p3(y3);
        }
      };
      t3.value && n3.value && Vn.triggerDragEvent(t3.value, s3);
    }), { barElement: t3, cursorElement: n3, getCursorStyle: h3, getBackgroundStyle: c3, onClickSider: _3 };
  }
});
var Qe2 = (e2) => (pushScopeId("data-v-18925ba6"), e2 = e2(), popScopeId(), e2);
var xe2 = Qe2(() => createBaseVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
var et2 = [
  xe2
];
function tt2(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": e2.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle(e2.getBackgroundStyle),
      onClick: o3[0] || (o3[0] = (...c3) => e2.onClickSider && e2.onClickSider(...c3))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(e2.getCursorStyle)
      }, et2, 6)
    ], 4)
  ], 2);
}
var ue2 = G2(Je2, [["render", tt2], ["__scopeId", "data-v-18925ba6"]]);
var ot2 = [
  // 
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  // 
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  // 
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  // 
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  // 
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  // 
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
];
var nt2 = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(e2, { emit: o3 }) {
    return { palettes: ot2, computedBgStyle: (l3) => l3 === "transparent" ? l3 : l3 === "advance" ? {} : { background: tinycolor(l3).toRgbString() }, onColorChange: (l3) => {
      o3("change", l3);
    } };
  }
});
var at2 = { class: "vc-compact" };
var rt2 = ["onClick"];
function st2(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", at2, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(e2.palettes, (c3, a3) => (openBlock(), createElementBlock("div", {
      key: a3,
      class: "vc-compact__row"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(c3, (h3, _3) => (openBlock(), createElementBlock("div", {
        key: _3,
        class: "vc-compact__color-cube--wrap",
        onClick: (p3) => e2.onColorChange(h3)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            "vc-compact__color_cube",
            {
              advance: h3 === "advance",
              transparent: h3 === "transparent"
            }
          ]),
          style: normalizeStyle(e2.computedBgStyle(h3))
        }, null, 6)
      ], 8, rt2))), 128))
    ]))), 128))
  ]);
}
var Pe2 = G2(nt2, [["render", st2], ["__scopeId", "data-v-b969fd48"]]);
var lt2 = defineComponent({
  name: "Board",
  props: {
    color: C.instanceOf(w3),
    round: C.bool.def(false),
    hide: C.bool.def(true)
  },
  emits: ["change"],
  setup(e2, { emit: o3 }) {
    var C3, g3, $3;
    const t3 = getCurrentInstance(), n3 = {
      h: ((C3 = e2.color) == null ? void 0 : C3.hue) || 0,
      s: 1,
      v: 1
    }, l3 = new w3(n3).toHexString(), r3 = reactive({
      hueColor: l3,
      saturation: ((g3 = e2.color) == null ? void 0 : g3.saturation) || 0,
      brightness: (($3 = e2.color) == null ? void 0 : $3.brightness) || 0
    }), c3 = ref(0), a3 = ref(0), h3 = ref(), _3 = ref(), p3 = computed(() => ({
      top: c3.value + "px",
      left: a3.value + "px"
    })), s3 = () => {
      if (t3) {
        const b3 = t3.vnode.el;
        a3.value = r3.saturation * (b3 == null ? void 0 : b3.clientWidth), c3.value = (1 - r3.brightness) * (b3 == null ? void 0 : b3.clientHeight);
      }
    }, y3 = (b3) => {
      b3.target !== _3.value && m3(b3);
    }, m3 = (b3) => {
      if (t3) {
        const M3 = t3.vnode.el, q2 = M3 == null ? void 0 : M3.getBoundingClientRect();
        let Z2 = b3.clientX - q2.left, X = b3.clientY - q2.top;
        Z2 = re2(Z2, 0, q2.width), X = re2(X, 0, q2.height);
        const z3 = Z2 / q2.width, j3 = re2(-(X / q2.height) + 1, 0, 1);
        a3.value = Z2, c3.value = X, r3.saturation = z3, r3.brightness = j3, o3("change", z3, j3);
      }
    };
    return tryOnMounted(() => {
      t3 && t3.vnode.el && h3.value && (Vn.triggerDragEvent(h3.value, {
        drag: (b3) => {
          m3(b3);
        },
        end: (b3) => {
          m3(b3);
        }
      }), s3());
    }), whenever(
      () => e2.color,
      (b3) => {
        merge_default(r3, {
          hueColor: new w3({ h: b3.hue, s: 1, v: 1 }).toHexString(),
          saturation: b3.saturation,
          brightness: b3.brightness
        }), s3();
      },
      { deep: true }
    ), { state: r3, cursorElement: h3, getCursorStyle: p3, onClickBoard: y3 };
  }
});
var de2 = (e2) => (pushScopeId("data-v-63803390"), e2 = e2(), popScopeId(), e2);
var it2 = de2(() => createBaseVNode("div", { class: "vc-saturation__white" }, null, -1));
var ct2 = de2(() => createBaseVNode("div", { class: "vc-saturation__black" }, null, -1));
var ut2 = de2(() => createBaseVNode("div", null, null, -1));
var dt2 = [
  ut2
];
function ht2(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": e2.round, "vc-saturation__hidden": e2.hide }]),
    style: normalizeStyle({ backgroundColor: e2.state.hueColor }),
    onClick: o3[0] || (o3[0] = (...c3) => e2.onClickBoard && e2.onClickBoard(...c3))
  }, [
    it2,
    ct2,
    createBaseVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle(e2.getCursorStyle)
    }, dt2, 4)
  ], 6);
}
var he2 = G2(lt2, [["render", ht2], ["__scopeId", "data-v-63803390"]]);
var gt2 = defineComponent({
  name: "Hue",
  props: {
    color: C.instanceOf(w3),
    size: C.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(e2, { emit: o3 }) {
    const t3 = ref(null), n3 = ref(null);
    let l3 = e2.color || new w3();
    const r3 = reactive({
      hue: l3.hue || 0
    });
    watch(
      () => e2.color,
      (p3) => {
        p3 && (l3 = p3, merge_default(r3, { hue: l3.hue }));
      },
      { deep: true }
    );
    const c3 = () => {
      if (t3.value && n3.value) {
        const p3 = t3.value.getBoundingClientRect(), s3 = n3.value.offsetWidth;
        return r3.hue === 360 ? p3.width - s3 / 2 : r3.hue % 360 * (p3.width - s3) / 360 + s3 / 2;
      }
      return 0;
    }, a3 = computed(() => ({
      left: c3() + "px",
      top: 0
    })), h3 = (p3) => {
      p3.target !== t3.value && _3(p3);
    }, _3 = (p3) => {
      if (p3.stopPropagation(), t3.value && n3.value) {
        const s3 = t3.value.getBoundingClientRect(), y3 = n3.value.offsetWidth;
        let m3 = p3.clientX - s3.left;
        m3 = Math.min(m3, s3.width - y3 / 2), m3 = Math.max(y3 / 2, m3);
        const C3 = Math.round((m3 - y3 / 2) / (s3.width - y3) * 360);
        l3.hue = C3, r3.hue = C3, o3("change", C3);
      }
    };
    return tryOnMounted(() => {
      const p3 = {
        drag: (s3) => {
          _3(s3);
        },
        end: (s3) => {
          _3(s3);
        }
      };
      t3.value && n3.value && Vn.triggerDragEvent(t3.value, p3);
    }), { barElement: t3, cursorElement: n3, getCursorStyle: a3, onClickSider: h3 };
  }
});
var pt2 = (e2) => (pushScopeId("data-v-5c4cae5b"), e2 = e2(), popScopeId(), e2);
var Ct2 = pt2(() => createBaseVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
var vt2 = [
  Ct2
];
function ft2(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": e2.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: o3[0] || (o3[0] = (...c3) => e2.onClickSider && e2.onClickSider(...c3))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(e2.getCursorStyle)
      }, vt2, 6)
    ], 512)
  ], 2);
}
var ge2 = G2(gt2, [["render", ft2], ["__scopeId", "data-v-5c4cae5b"]]);
var _t2 = defineComponent({
  name: "Lightness",
  props: {
    color: C.instanceOf(w3),
    size: C.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(e2, { emit: o3 }) {
    const t3 = ref(null), n3 = ref(null);
    let l3 = e2.color || new w3();
    const [r3, c3, a3] = l3.HSL, h3 = reactive({
      hue: r3,
      saturation: c3,
      lightness: a3
    });
    watch(
      () => e2.color,
      (C3) => {
        if (C3) {
          l3 = C3;
          const [g3, $3, b3] = l3.HSL;
          merge_default(h3, {
            hue: g3,
            saturation: $3,
            lightness: b3
          });
        }
      },
      { deep: true }
    );
    const _3 = computed(() => {
      const C3 = tinycolor({
        h: h3.hue,
        s: h3.saturation,
        l: 0.8
      }).toPercentageRgbString(), g3 = tinycolor({
        h: h3.hue,
        s: h3.saturation,
        l: 0.6
      }).toPercentageRgbString(), $3 = tinycolor({
        h: h3.hue,
        s: h3.saturation,
        l: 0.4
      }).toPercentageRgbString(), b3 = tinycolor({
        h: h3.hue,
        s: h3.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${C3}, ${g3}, ${$3}, ${b3}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${C3}, ${g3}, ${$3}, ${b3}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${C3}, ${g3}, ${$3}, ${b3}, rgb(0, 0, 0))`
        ]
      };
    }), p3 = () => {
      if (t3.value && n3.value) {
        const C3 = h3.lightness, g3 = t3.value.getBoundingClientRect(), $3 = n3.value.offsetWidth;
        return (1 - C3) * (g3.width - $3) + $3 / 2;
      }
      return 0;
    }, s3 = computed(() => ({
      left: p3() + "px",
      top: 0
    })), y3 = (C3) => {
      C3.target !== t3.value && m3(C3);
    }, m3 = (C3) => {
      if (C3.stopPropagation(), t3.value && n3.value) {
        const g3 = t3.value.getBoundingClientRect(), $3 = n3.value.offsetWidth;
        let b3 = C3.clientX - g3.left;
        b3 = Math.max($3 / 2, b3), b3 = Math.min(b3, g3.width - $3 / 2);
        const M3 = 1 - (b3 - $3 / 2) / (g3.width - $3);
        l3.lightness = M3, o3("change", M3);
      }
    };
    return tryOnMounted(() => {
      const C3 = {
        drag: (g3) => {
          m3(g3);
        },
        end: (g3) => {
          m3(g3);
        }
      };
      t3.value && n3.value && Vn.triggerDragEvent(t3.value, C3);
    }), { barElement: t3, cursorElement: n3, getCursorStyle: s3, getBackgroundStyle: _3, onClickSider: y3 };
  }
});
var bt2 = (e2) => (pushScopeId("data-v-6156acb7"), e2 = e2(), popScopeId(), e2);
var yt2 = bt2(() => createBaseVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
var mt2 = [
  yt2
];
function St2(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": e2.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle(e2.getBackgroundStyle),
      onClick: o3[0] || (o3[0] = (...c3) => e2.onClickSider && e2.onClickSider(...c3))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(e2.getCursorStyle)
      }, mt2, 6)
    ], 4)
  ], 2);
}
var Ve2 = G2(_t2, [["render", St2], ["__scopeId", "data-v-6156acb7"]]);
var $t2 = defineComponent({
  name: "History",
  props: {
    colors: C.arrayOf(String).def(() => []),
    round: C.bool.def(false)
  },
  emits: ["change"],
  setup(e2, { emit: o3 }) {
    return { onColorSelect: (n3) => {
      o3("change", n3);
    } };
  }
});
var kt2 = {
  key: 0,
  class: "vc-colorPicker__record"
};
var wt2 = { class: "color-list" };
var Ht2 = ["onClick"];
function Bt2(e2, o3, t3, n3, l3, r3) {
  return e2.colors && e2.colors.length > 0 ? (openBlock(), createElementBlock("div", kt2, [
    createBaseVNode("div", wt2, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e2.colors, (c3, a3) => (openBlock(), createElementBlock("div", {
        key: a3,
        class: normalizeClass(["color-item", "transparent", { "color-item__round": e2.round }]),
        onClick: (h3) => e2.onColorSelect(c3)
      }, [
        createBaseVNode("div", {
          class: "color-item__display",
          style: normalizeStyle({ backgroundColor: c3 })
        }, null, 4)
      ], 10, Ht2))), 128))
    ])
  ])) : createCommentVNode("", true);
}
var pe2 = G2($t2, [["render", Bt2], ["__scopeId", "data-v-7e6b67ca"]]);
var At2 = defineComponent({
  name: "Display",
  props: {
    color: C.instanceOf(w3),
    disableAlpha: C.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(e2, { emit: o3 }) {
    var c3, a3, h3;
    const t3 = reactive({
      color: e2.color,
      hex: (c3 = e2.color) == null ? void 0 : c3.hex,
      alpha: ((a3 = e2.color) == null ? void 0 : a3.alpha) + "%",
      previewBgColor: (h3 = e2.color) == null ? void 0 : h3.toRgbString()
    }), n3 = computed(() => ({
      background: t3.previewBgColor
    })), l3 = useDebounceFn((_3) => {
      if (!_3.target.value)
        return;
      const p3 = parseInt(_3.target.value.replace("%", ""));
      !isNaN(p3) && t3.color && (t3.color.alpha = p3), o3("update:color", t3.color), o3("change", t3.color);
    }, 300), r3 = useDebounceFn((_3) => {
      if (!_3.target.value)
        return;
      const p3 = _3.target.value.replace("#", "");
      tinycolor(p3).isValid() && t3.color && (t3.color.hex = p3), o3("update:color", t3.color), o3("change", t3.color);
    }, 300);
    return whenever(
      () => e2.color,
      (_3) => {
        _3 && (t3.color = _3, t3.alpha = t3.color.alpha + "%", t3.hex = t3.color.hex);
      },
      { deep: true }
    ), whenever(
      () => t3.color,
      () => {
        t3.color && (t3.previewBgColor = t3.color.toRgbString());
      },
      { deep: true }
    ), { state: t3, getBgColorStyle: n3, onAlphaBlur: l3, onInputChange: r3 };
  }
});
var Rt2 = { class: "vc-display" };
var Pt2 = { class: "vc-current-color vc-transparent" };
var Vt2 = { class: "vc-color-input" };
var Kt2 = ["value"];
var It2 = {
  key: 0,
  class: "vc-alpha-input"
};
var Et2 = ["value"];
function Lt2(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", Rt2, [
    createBaseVNode("div", Pt2, [
      createBaseVNode("div", {
        class: "color-cube",
        style: normalizeStyle(e2.getBgColorStyle)
      }, null, 4)
    ]),
    createBaseVNode("div", Vt2, [
      createBaseVNode("input", {
        value: e2.state.hex,
        onInput: o3[0] || (o3[0] = (...c3) => e2.onInputChange && e2.onInputChange(...c3))
      }, null, 40, Kt2)
    ]),
    e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", It2, [
      createBaseVNode("input", {
        class: "vc-alpha-input__inner",
        value: e2.state.alpha,
        onInput: o3[1] || (o3[1] = (...c3) => e2.onAlphaBlur && e2.onAlphaBlur(...c3))
      }, null, 40, Et2)
    ]))
  ]);
}
var Ce2 = G2(At2, [["render", Lt2], ["__scopeId", "data-v-ffdc53e2"]]);
var Wt2 = defineComponent({
  name: "FkColorPicker",
  components: { Display: Ce2, Alpha: ue2, Palette: Pe2, Board: he2, Hue: ge2, Lightness: Ve2, History: pe2 },
  props: {
    color: C.instanceOf(w3),
    disableHistory: C.bool.def(false),
    roundHistory: C.bool.def(false),
    disableAlpha: C.bool.def(false)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(e2, { emit: o3 }) {
    const t3 = e2.color || new w3(), n3 = reactive({
      color: t3,
      hex: t3.toHexString(),
      rgb: t3.toRgbString()
    }), l3 = ref(false), r3 = computed(() => ({ background: n3.rgb })), c3 = () => {
      l3.value = false, o3("advanceChange", false);
    }, a3 = useLocalStorage(ie2, [], {}), h3 = useDebounceFn(() => {
      if (e2.disableHistory)
        return;
      const g3 = n3.color.toRgbString();
      if (a3.value = a3.value.filter(($3) => !tinycolor.equals($3, g3)), !a3.value.includes(g3)) {
        for (; a3.value.length > ce2; )
          a3.value.pop();
        a3.value.unshift(g3);
      }
    }, 500), _3 = (g3) => {
      g3 === "advance" ? (l3.value = true, o3("advanceChange", true)) : (n3.color.hex = g3, o3("advanceChange", false));
    }, p3 = (g3) => {
      n3.color.alpha = g3;
    }, s3 = (g3) => {
      n3.color.hue = g3;
    }, y3 = (g3, $3) => {
      n3.color.saturation = g3, n3.color.brightness = $3;
    }, m3 = (g3) => {
      n3.color.lightness = g3;
    }, C3 = (g3) => {
      const b3 = g3.target.value.replace("#", "");
      tinycolor(b3).isValid() && (n3.color.hex = b3);
    };
    return whenever(
      () => e2.color,
      (g3) => {
        g3 && (n3.color = g3);
      },
      { deep: true }
    ), whenever(
      () => n3.color,
      () => {
        n3.hex = n3.color.hex, n3.rgb = n3.color.toRgbString(), h3(), o3("update:color", n3.color), o3("change", n3.color);
      },
      { deep: true }
    ), {
      state: n3,
      advancePanelShow: l3,
      onBack: c3,
      onCompactChange: _3,
      onAlphaChange: p3,
      onHueChange: s3,
      onBoardChange: y3,
      onLightChange: m3,
      onInputChange: C3,
      previewStyle: r3,
      historyColors: a3
    };
  }
});
var Mt2 = (e2) => (pushScopeId("data-v-592a5ec3"), e2 = e2(), popScopeId(), e2);
var Dt2 = { class: "vc-fk-colorPicker" };
var Nt2 = { class: "vc-fk-colorPicker__inner" };
var Ot2 = { class: "vc-fk-colorPicker__header" };
var zt2 = Mt2(() => createBaseVNode("div", { class: "back" }, null, -1));
var Tt2 = [
  zt2
];
function Gt2(e2, o3, t3, n3, l3, r3) {
  const c3 = resolveComponent("Palette"), a3 = resolveComponent("Board"), h3 = resolveComponent("Hue"), _3 = resolveComponent("Lightness"), p3 = resolveComponent("Alpha"), s3 = resolveComponent("Display"), y3 = resolveComponent("History");
  return openBlock(), createElementBlock("div", Dt2, [
    createBaseVNode("div", Nt2, [
      createBaseVNode("div", Ot2, [
        e2.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { cursor: "pointer" },
          onClick: o3[0] || (o3[0] = (...m3) => e2.onBack && e2.onBack(...m3))
        }, Tt2)) : createCommentVNode("", true)
      ]),
      e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(c3, {
        key: 0,
        onChange: e2.onCompactChange
      }, null, 8, ["onChange"])),
      e2.advancePanelShow ? (openBlock(), createBlock(a3, {
        key: 1,
        color: e2.state.color,
        onChange: e2.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      e2.advancePanelShow ? (openBlock(), createBlock(h3, {
        key: 2,
        color: e2.state.color,
        onChange: e2.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(_3, {
        key: 3,
        color: e2.state.color,
        onChange: e2.onLightChange
      }, null, 8, ["color", "onChange"])),
      e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(p3, {
        key: 4,
        color: e2.state.color,
        onChange: e2.onAlphaChange
      }, null, 8, ["color", "onChange"])),
      createVNode(s3, {
        color: e2.state.color,
        "disable-alpha": e2.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(y3, {
        key: 5,
        round: e2.roundHistory,
        colors: e2.historyColors,
        onChange: e2.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
var ke2 = G2(Wt2, [["render", Gt2], ["__scopeId", "data-v-592a5ec3"]]);
var Ft2 = defineComponent({
  name: "ChromeColorPicker",
  components: { Display: Ce2, Alpha: ue2, Board: he2, Hue: ge2, History: pe2 },
  props: {
    color: C.instanceOf(w3),
    disableHistory: C.bool.def(false),
    roundHistory: C.bool.def(false),
    disableAlpha: C.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(e2, { emit: o3 }) {
    const t3 = e2.color || new w3(), n3 = reactive({
      color: t3,
      hex: t3.toHexString(),
      rgb: t3.toRgbString()
    }), l3 = computed(() => ({ background: n3.rgb })), r3 = useLocalStorage(ie2, [], {}), c3 = useDebounceFn(() => {
      if (e2.disableHistory)
        return;
      const s3 = n3.color.toRgbString();
      if (r3.value = r3.value.filter((y3) => !tinycolor.equals(y3, s3)), !r3.value.includes(s3)) {
        for (; r3.value.length > ce2; )
          r3.value.pop();
        r3.value.unshift(s3);
      }
    }, 500), a3 = (s3) => {
      n3.color.alpha = s3;
    }, h3 = (s3) => {
      n3.color.hue = s3;
    }, _3 = (s3, y3) => {
      n3.color.saturation = s3, n3.color.brightness = y3;
    }, p3 = (s3) => {
      s3 !== "advance" && (n3.color.hex = s3);
    };
    return whenever(
      () => e2.color,
      (s3) => {
        s3 && (n3.color = s3);
      },
      { deep: true }
    ), whenever(
      () => n3.color,
      () => {
        n3.hex = n3.color.hex, n3.rgb = n3.color.toRgbString(), c3(), o3("update:color", n3.color), o3("change", n3.color);
      },
      { deep: true }
    ), {
      state: n3,
      previewStyle: l3,
      historyColors: r3,
      onAlphaChange: a3,
      onHueChange: h3,
      onBoardChange: _3,
      onCompactChange: p3
    };
  }
});
var qt2 = { class: "vc-chrome-colorPicker" };
var Xt2 = { class: "vc-chrome-colorPicker-body" };
var Zt2 = { class: "chrome-controls" };
var Ut2 = { class: "chrome-color-wrap transparent" };
var jt2 = { class: "chrome-sliders" };
function Yt2(e2, o3, t3, n3, l3, r3) {
  const c3 = resolveComponent("Board"), a3 = resolveComponent("Hue"), h3 = resolveComponent("Alpha"), _3 = resolveComponent("Display"), p3 = resolveComponent("History");
  return openBlock(), createElementBlock("div", qt2, [
    createVNode(c3, {
      round: true,
      hide: false,
      color: e2.state.color,
      onChange: e2.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createBaseVNode("div", Xt2, [
      createBaseVNode("div", Zt2, [
        createBaseVNode("div", Ut2, [
          createBaseVNode("div", {
            class: "current-color",
            style: normalizeStyle(e2.previewStyle)
          }, null, 4)
        ]),
        createBaseVNode("div", jt2, [
          createVNode(a3, {
            size: "small",
            color: e2.state.color,
            onChange: e2.onHueChange
          }, null, 8, ["color", "onChange"]),
          e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(h3, {
            key: 0,
            size: "small",
            color: e2.state.color,
            onChange: e2.onAlphaChange
          }, null, 8, ["color", "onChange"]))
        ])
      ]),
      createVNode(_3, {
        color: e2.state.color,
        "disable-alpha": e2.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(p3, {
        key: 0,
        round: e2.roundHistory,
        colors: e2.historyColors,
        onChange: e2.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
var we2 = G2(Ft2, [["render", Yt2], ["__scopeId", "data-v-61d7303b"]]);
var ve2 = "Vue3ColorPickerProvider";
var Jt2 = defineComponent({
  name: "GradientColorPicker",
  components: { Angle, Display: Ce2, Alpha: ue2, Palette: Pe2, Board: he2, Hue: ge2, Lightness: Ve2, History: pe2 },
  props: {
    startColor: C.instanceOf(w3).isRequired,
    endColor: C.instanceOf(w3).isRequired,
    startColorStop: C.number.def(0),
    endColorStop: C.number.def(100),
    angle: C.number.def(0),
    disableHistory: C.bool.def(false),
    roundHistory: C.bool.def(false),
    disableAlpha: C.bool.def(false)
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange"
  ],
  setup(e2, { emit: o3 }) {
    const t3 = reactive({
      startActive: true,
      startColor: e2.startColor,
      endColor: e2.endColor,
      startColorStop: e2.startColorStop,
      endColorStop: e2.endColorStop,
      angle: e2.angle,
      // rgba
      startColorRgba: e2.startColor.toRgbString(),
      endColorRgba: e2.endColor.toRgbString()
    }), n3 = inject(ve2), l3 = ref(false), r3 = ref(), c3 = ref(), a3 = ref();
    watch(
      () => [e2.startColor, e2.endColor, e2.angle],
      (u3) => {
        t3.startColor = u3[0], t3.endColor = u3[1], t3.angle = u3[2];
      }
    );
    const h3 = computed({
      get: () => t3.startActive ? t3.startColor : t3.endColor,
      set: (u3) => {
        if (t3.startActive) {
          t3.startColor = u3;
          return;
        }
        t3.endColor = u3;
      }
    }), _3 = computed(() => {
      if (a3.value && r3.value) {
        const u3 = t3.startColorStop / 100, k2 = a3.value.getBoundingClientRect(), S3 = r3.value.offsetWidth;
        return Math.round(u3 * (k2.width - S3) + S3 / 2);
      }
      return 0;
    }), p3 = computed(() => {
      if (a3.value && c3.value) {
        const u3 = t3.endColorStop / 100, k2 = a3.value.getBoundingClientRect(), S3 = c3.value.offsetWidth;
        return Math.round(u3 * (k2.width - S3) + S3 / 2);
      }
      return 0;
    }), s3 = computed(() => ({
      background: `linear-gradient(${t3.angle}deg, ${t3.startColorRgba} ${t3.startColorStop}%, ${t3.endColorRgba} ${t3.endColorStop}%)`
    })), y3 = (u3) => {
      var k2;
      if (t3.startActive = true, a3.value && r3.value) {
        const S3 = (k2 = a3.value) == null ? void 0 : k2.getBoundingClientRect();
        let N3 = u3.clientX - S3.left;
        N3 = Math.max(r3.value.offsetWidth / 2, N3), N3 = Math.min(N3, S3.width - r3.value.offsetWidth / 2), t3.startColorStop = Math.round(
          (N3 - r3.value.offsetWidth / 2) / (S3.width - r3.value.offsetWidth) * 100
        ), o3("update:startColorStop", t3.startColorStop), o3("startColorStopChange", t3.startColorStop);
      }
    }, m3 = (u3) => {
      var k2;
      if (t3.startActive = false, a3.value && c3.value) {
        const S3 = (k2 = a3.value) == null ? void 0 : k2.getBoundingClientRect();
        let N3 = u3.clientX - S3.left;
        N3 = Math.max(c3.value.offsetWidth / 2, N3), N3 = Math.min(N3, S3.width - c3.value.offsetWidth / 2), t3.endColorStop = Math.round(
          (N3 - c3.value.offsetWidth / 2) / (S3.width - c3.value.offsetWidth) * 100
        ), o3("update:endColorStop", t3.endColorStop), o3("endColorStopChange", t3.endColorStop);
      }
    }, C3 = (u3) => {
      const k2 = u3.target, S3 = parseInt(k2.value.replace("", ""));
      isNaN(S3) || (t3.angle = S3 % 360), o3("update:angle", t3.angle), o3("angleChange", t3.angle);
    }, g3 = (u3) => {
      t3.angle = u3, o3("update:angle", t3.angle), o3("angleChange", t3.angle);
    }, $3 = (u3) => {
      u3 === "advance" ? (l3.value = true, o3("advanceChange", true)) : (h3.value.hex = u3, o3("advanceChange", false)), z3();
    }, b3 = (u3) => {
      h3.value.alpha = u3, z3();
    }, M3 = (u3) => {
      h3.value.hue = u3, z3();
    }, q2 = (u3, k2) => {
      h3.value.saturation = u3, h3.value.brightness = k2, z3();
    }, Z2 = (u3) => {
      h3.value.lightness = u3, z3();
    }, X = () => {
      z3();
    }, z3 = () => {
      t3.startActive ? (o3("update:startColor", t3.startColor), o3("startColorChange", t3.startColor)) : (o3("update:endColor", t3.endColor), o3("endColorChange", t3.endColor));
    }, j3 = () => {
      l3.value = false, o3("advanceChange", false);
    }, d3 = useLocalStorage(ie2, [], {}), D3 = useDebounceFn(() => {
      if (e2.disableHistory)
        return;
      const u3 = h3.value.toRgbString();
      if (d3.value = d3.value.filter((k2) => !tinycolor.equals(k2, u3)), !d3.value.includes(u3)) {
        for (; d3.value.length > ce2; )
          d3.value.pop();
        d3.value.unshift(u3);
      }
    }, 500);
    return tryOnMounted(() => {
      c3.value && r3.value && (Vn.triggerDragEvent(c3.value, {
        drag: (u3) => {
          m3(u3);
        },
        end: (u3) => {
          m3(u3);
        }
      }), Vn.triggerDragEvent(r3.value, {
        drag: (u3) => {
          y3(u3);
        },
        end: (u3) => {
          y3(u3);
        }
      }));
    }), whenever(
      () => t3.startColor,
      (u3) => {
        t3.startColorRgba = u3.toRgbString();
      },
      { deep: true }
    ), whenever(
      () => t3.endColor,
      (u3) => {
        t3.endColorRgba = u3.toRgbString();
      },
      { deep: true }
    ), whenever(
      () => h3.value,
      () => {
        D3();
      },
      { deep: true }
    ), {
      startGradientRef: r3,
      stopGradientRef: c3,
      colorRangeRef: a3,
      state: t3,
      currentColor: h3,
      getStartColorLeft: _3,
      getEndColorLeft: p3,
      gradientBg: s3,
      advancePanelShow: l3,
      onDegreeBlur: C3,
      onCompactChange: $3,
      onAlphaChange: b3,
      onHueChange: M3,
      onBoardChange: q2,
      onLightChange: Z2,
      historyColors: d3,
      onBack: j3,
      onDegreeChange: g3,
      onDisplayChange: X,
      lang: n3 == null ? void 0 : n3.lang
    };
  }
});
var fe2 = (e2) => (pushScopeId("data-v-46339c64"), e2 = e2(), popScopeId(), e2);
var Qt2 = { class: "vc-gradient-picker" };
var xt2 = { class: "vc-gradient-picker__header" };
var eo2 = fe2(() => createBaseVNode("div", { class: "back" }, null, -1));
var to2 = [
  eo2
];
var oo2 = { class: "vc-gradient-picker__body" };
var no2 = {
  class: "vc-color-range",
  ref: "colorRangeRef"
};
var ao2 = { class: "vc-color-range__container" };
var ro2 = { class: "vc-gradient__stop__container" };
var so2 = ["title"];
var lo2 = fe2(() => createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
var io2 = [
  lo2
];
var co2 = ["title"];
var uo2 = fe2(() => createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
var ho2 = [
  uo2
];
var go2 = { class: "vc-picker-degree-input vc-degree-input" };
var po2 = { class: "vc-degree-input__control" };
var Co2 = ["value"];
var vo2 = { class: "vc-degree-input__panel" };
var fo2 = { class: "vc-degree-input__disk" };
function _o2(e2, o3, t3, n3, l3, r3) {
  const c3 = resolveComponent("Angle"), a3 = resolveComponent("Palette"), h3 = resolveComponent("Board"), _3 = resolveComponent("Hue"), p3 = resolveComponent("Lightness"), s3 = resolveComponent("Alpha"), y3 = resolveComponent("Display"), m3 = resolveComponent("History");
  return openBlock(), createElementBlock("div", Qt2, [
    withDirectives(createBaseVNode("div", xt2, [
      createBaseVNode("span", {
        style: { cursor: "pointer" },
        onClick: o3[0] || (o3[0] = (...C3) => e2.onBack && e2.onBack(...C3))
      }, to2)
    ], 512), [
      [vShow, e2.advancePanelShow]
    ]),
    createBaseVNode("div", oo2, [
      createBaseVNode("div", no2, [
        createBaseVNode("div", ao2, [
          createBaseVNode("div", {
            class: "vc-background",
            style: normalizeStyle(e2.gradientBg)
          }, null, 4),
          createBaseVNode("div", ro2, [
            createBaseVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": e2.state.startActive
              }]),
              ref: "startGradientRef",
              title: e2.lang === "ZH-cn" ? "" : "Start",
              style: normalizeStyle({ left: e2.getStartColorLeft + "px" })
            }, io2, 14, so2),
            createBaseVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": !e2.state.startActive
              }]),
              ref: "stopGradientRef",
              title: e2.lang === "ZH-cn" ? "" : "End",
              style: normalizeStyle({ left: e2.getEndColorLeft + "px" })
            }, ho2, 14, co2)
          ])
        ])
      ], 512),
      createBaseVNode("div", go2, [
        createBaseVNode("div", po2, [
          createBaseVNode("input", {
            value: e2.state.angle,
            onBlur: o3[1] || (o3[1] = (...C3) => e2.onDegreeBlur && e2.onDegreeBlur(...C3))
          }, null, 40, Co2)
        ]),
        createBaseVNode("div", vo2, [
          createBaseVNode("div", fo2, [
            createVNode(c3, {
              angle: e2.state.angle,
              "onUpdate:angle": o3[2] || (o3[2] = (C3) => e2.state.angle = C3),
              size: 40,
              onChange: e2.onDegreeChange
            }, null, 8, ["angle", "onChange"])
          ])
        ])
      ])
    ]),
    e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(a3, {
      key: 0,
      onChange: e2.onCompactChange
    }, null, 8, ["onChange"])),
    e2.advancePanelShow ? (openBlock(), createBlock(h3, {
      key: 1,
      color: e2.currentColor,
      onChange: e2.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    e2.advancePanelShow ? (openBlock(), createBlock(_3, {
      key: 2,
      color: e2.currentColor,
      onChange: e2.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(p3, {
      key: 3,
      color: e2.currentColor,
      onChange: e2.onLightChange
    }, null, 8, ["color", "onChange"])),
    e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(s3, {
      key: 4,
      color: e2.currentColor,
      onChange: e2.onAlphaChange
    }, null, 8, ["color", "onChange"])),
    createVNode(y3, {
      color: e2.currentColor,
      "disable-alpha": e2.disableAlpha,
      onChange: e2.onDisplayChange
    }, null, 8, ["color", "disable-alpha", "onChange"]),
    e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(m3, {
      key: 5,
      round: e2.roundHistory,
      colors: e2.historyColors,
      onChange: e2.onCompactChange
    }, null, 8, ["round", "colors", "onChange"]))
  ]);
}
var He2 = G2(Jt2, [["render", _o2], ["__scopeId", "data-v-46339c64"]]);
var bo2 = defineComponent({
  name: "WrapContainer",
  props: {
    showTab: C.bool.def(false),
    activeKey: C.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(e2, { emit: o3 }) {
    const t3 = reactive({
      activeKey: e2.activeKey
    }), n3 = inject(ve2), l3 = (r3) => {
      t3.activeKey = r3, o3("update:activeKey", r3), o3("change", r3);
    };
    return whenever(
      () => e2.activeKey,
      (r3) => {
        t3.activeKey = r3;
      }
    ), { state: t3, onActiveKeyChange: l3, lang: n3 == null ? void 0 : n3.lang };
  }
});
var yo2 = { class: "vc-colorpicker" };
var mo2 = { class: "vc-colorpicker--container" };
var So2 = {
  key: 0,
  class: "vc-colorpicker--tabs"
};
var $o = { class: "vc-colorpicker--tabs__inner" };
var ko2 = { class: "vc-btn__content" };
var wo2 = { class: "vc-btn__content" };
function Ho(e2, o3, t3, n3, l3, r3) {
  return openBlock(), createElementBlock("div", yo2, [
    createBaseVNode("div", mo2, [
      e2.showTab ? (openBlock(), createElementBlock("div", So2, [
        createBaseVNode("div", $o, [
          createBaseVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": e2.state.activeKey === "pure"
              }
            ]),
            onClick: o3[0] || (o3[0] = (c3) => e2.onActiveKeyChange("pure"))
          }, [
            createBaseVNode("button", null, [
              createBaseVNode("div", ko2, toDisplayString(e2.lang === "ZH-cn" ? "" : "Pure"), 1)
            ])
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": e2.state.activeKey === "gradient"
              }
            ]),
            onClick: o3[1] || (o3[1] = (c3) => e2.onActiveKeyChange("gradient"))
          }, [
            createBaseVNode("button", null, [
              createBaseVNode("div", wo2, toDisplayString(e2.lang === "ZH-cn" ? "" : "Gradient"), 1)
            ])
          ], 2),
          createBaseVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle({
              width: "50%",
              left: `calc(${e2.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      renderSlot(e2.$slots, "default", {}, void 0, true)
    ])
  ]);
}
var Bo = G2(bo2, [["render", Ho], ["__scopeId", "data-v-4afdf3bb"]]);
var Ao2 = {
  isWidget: C.bool.def(false),
  pickerType: C.oneOf(["fk", "chrome"]).def("fk"),
  shape: C.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: C.string.def(
    "linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 100%)"
  ),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: C.bool.def(false),
  disableHistory: C.bool.def(false),
  roundHistory: C.bool.def(false),
  useType: C.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: C.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: C.number.def(9999)
};
var Ro2 = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker: ke2, ChromeColorPicker: we2, GradientColorPicker: He2, WrapContainer: Bo },
  inheritAttrs: false,
  props: Ao2,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(e2, { emit: o3 }) {
    const t3 = reactive({
      pureColor: e2.pureColor || "",
      activeKey: e2.useType === "gradient" ? "gradient" : e2.activeKey,
      //  "pure" | "gradient"
      isAdvanceMode: false
    });
    provide(ve2, {
      lang: computed(() => e2.lang || "ZH-cn")
    });
    const n3 = new w3(t3.pureColor), l3 = ref(n3), r3 = new w3("#000"), c3 = new w3("#000"), a3 = reactive({
      startColor: r3,
      endColor: c3,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      gradientColor: e2.gradientColor
    }), h3 = ref(false), _3 = ref(null), p3 = ref(null), s3 = computed(() => ({
      background: t3.activeKey !== "gradient" ? tinycolor(t3.pureColor).toRgbString() : a3.gradientColor
    })), y3 = computed(() => t3.activeKey === "gradient" ? He2.name : e2.pickerType === "fk" ? ke2.name : we2.name), m3 = computed(() => t3.activeKey === "gradient" ? {
      startColor: a3.startColor,
      endColor: a3.endColor,
      onStartColorChange: (d3) => {
        a3.startColor = d3, M3();
      },
      onEndColorChange: (d3) => {
        a3.endColor = d3, M3();
      },
      angle: a3.angle,
      startColorStop: a3.startColorStop,
      endColorStop: a3.endColorStop,
      onStartColorStopChange: (d3) => {
        a3.startColorStop = d3, M3();
      },
      onEndColorStopChange: (d3) => {
        a3.endColorStop = d3, M3();
      },
      onAngleChange: (d3) => {
        a3.angle = d3, M3();
      },
      onAdvanceChange: (d3) => {
        t3.isAdvanceMode = d3;
      }
    } : {
      disableAlpha: e2.disableAlpha,
      disableHistory: e2.disableHistory,
      roundHistory: e2.roundHistory,
      color: l3.value,
      onChange: X,
      onAdvanceChange: C3
    }), C3 = (d3) => {
      t3.isAdvanceMode = d3;
    }, g3 = () => {
      h3.value = true;
    }, $3 = () => {
      h3.value = false;
    }, b3 = () => {
      var d3, D3, u3, k2;
      try {
        const [S3] = (0, import_gradient_parser.parse)(a3.gradientColor);
        if (S3 && S3.type === "linear-gradient" && ((d3 = S3.orientation) == null ? void 0 : d3.type) === "angular" && S3.colorStops.length >= 2) {
          const N3 = S3.colorStops[0], _e2 = S3.colorStops[1];
          a3.startColorStop = Number((D3 = N3.length) == null ? void 0 : D3.value) || 0, a3.endColorStop = Number((u3 = _e2.length) == null ? void 0 : u3.value) || 0, a3.angle = Number((k2 = S3.orientation) == null ? void 0 : k2.value) || 0;
          const [Ke2, Ie2, Ee2, Le2] = N3.value, [We2, Me2, De2, Ne2] = _e2.value;
          a3.startColor = new w3({
            r: Number(Ke2),
            g: Number(Ie2),
            b: Number(Ee2),
            a: Number(Le2)
          }), a3.endColor = new w3({
            r: Number(We2),
            g: Number(Me2),
            b: Number(De2),
            a: Number(Ne2)
          });
        }
      } catch (S3) {
        console.log(`[Parse Color]: ${S3}`);
      }
    }, M3 = useDebounceFn(() => {
      const d3 = q2();
      try {
        a3.gradientColor = (0, import_gradient_parser.stringify)(d3), o3("update:gradientColor", a3.gradientColor), o3("gradientColorChange", a3.gradientColor);
      } catch (D3) {
        console.log(D3);
      }
    }, 300), q2 = () => {
      const d3 = [], D3 = a3.startColor.RGB.map((k2) => k2.toString()), u3 = a3.endColor.RGB.map((k2) => k2.toString());
      return d3.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: a3.angle + "" },
        colorStops: [
          {
            type: "rgba",
            value: [D3[0], D3[1], D3[2], D3[3]],
            length: { value: a3.startColorStop + "", type: "%" }
          },
          {
            type: "rgba",
            value: [u3[0], u3[1], u3[2], u3[3]],
            length: { value: a3.endColorStop + "", type: "%" }
          }
        ]
      }), d3;
    }, Z2 = () => {
      if (_3.value && p3.value) {
        const d3 = _3.value.offsetParent, D3 = _3.value.offsetTop || (d3 == null ? void 0 : d3.offsetTop), u3 = window.innerHeight - (D3 - window.pageYOffset) - _3.value.offsetHeight;
        createPopper3(_3.value, p3.value, {
          placement: "auto",
          modifiers: [
            {
              name: "flip",
              options: {
                boundary: u3 > 500 ? "clippingParents" : _3.value,
                fallbackPlacements: ["bottom", "left"]
              }
            }
          ]
        });
      }
    }, X = (d3) => {
      l3.value = d3, t3.pureColor = d3.toString(e2.format), z3();
    }, z3 = useDebounceFn(() => {
      o3("update:pureColor", t3.pureColor), o3("pureColorChange", t3.pureColor);
    }, 300);
    onClickOutside(p3, () => {
      $3();
    });
    const j3 = (d3) => {
      t3.activeKey = d3, o3("update:activeKey", d3), o3("activeKeyChange", d3);
    };
    return tryOnMounted(() => {
      b3(), Z2();
    }), whenever(
      () => e2.gradientColor,
      (d3) => {
        d3 != a3.gradientColor && (a3.gradientColor = d3);
      }
    ), whenever(
      () => a3.gradientColor,
      () => {
        b3();
      }
    ), whenever(
      () => e2.activeKey,
      (d3) => {
        t3.activeKey = d3;
      }
    ), whenever(
      () => e2.useType,
      (d3) => {
        t3.activeKey !== "gradient" && d3 === "gradient" ? t3.activeKey = "gradient" : t3.activeKey = "pure";
      }
    ), whenever(
      () => e2.pureColor,
      (d3) => {
        tinycolor.equals(d3, t3.pureColor) || (t3.pureColor = d3, l3.value = new w3(d3), z3());
      },
      { deep: true }
    ), {
      colorCubeRef: _3,
      pickerRef: p3,
      showPicker: h3,
      colorInstance: l3,
      getBgColorStyle: s3,
      onColorChange: X,
      onShowPicker: g3,
      onActiveKeyChange: j3,
      getComponentName: y3,
      getBindArgs: m3,
      state: t3
    };
  }
});
function Po2(e2, o3, t3, n3, l3, r3) {
  const c3 = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    e2.isWidget ? (openBlock(), createBlock(c3, {
      key: 0,
      "active-key": e2.state.activeKey,
      "onUpdate:active-key": o3[0] || (o3[0] = (a3) => e2.state.activeKey = a3),
      "show-tab": e2.useType === "both",
      onChange: e2.onActiveKeyChange,
      style: normalizeStyle({ zIndex: e2.zIndex })
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16))
      ]),
      _: 1
    }, 8, ["active-key", "show-tab", "onChange", "style"])) : createCommentVNode("", true),
    e2.isWidget ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-color-wrap transparent", { round: e2.shape === "circle" }]),
        ref: "colorCubeRef"
      }, [
        createBaseVNode("div", {
          class: "current-color",
          style: normalizeStyle(e2.getBgColorStyle),
          onClick: o3[1] || (o3[1] = (...a3) => e2.onShowPicker && e2.onShowPicker(...a3))
        }, null, 4)
      ], 2),
      (openBlock(), createBlock(Teleport, { to: "body" }, [
        withDirectives(createBaseVNode("div", {
          ref: "pickerRef",
          style: normalizeStyle({ zIndex: e2.zIndex })
        }, [
          e2.showPicker ? (openBlock(), createBlock(c3, {
            key: 0,
            "show-tab": e2.useType === "both" && !e2.state.isAdvanceMode,
            "active-key": e2.state.activeKey,
            "onUpdate:active-key": o3[2] || (o3[2] = (a3) => e2.state.activeKey = a3),
            onChange: e2.onActiveKeyChange
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16))
            ]),
            _: 1
          }, 8, ["show-tab", "active-key", "onChange"])) : createCommentVNode("", true)
        ], 4), [
          [vShow, e2.showPicker]
        ])
      ]))
    ], 64))
  ], 64);
}
var oe2 = G2(Ro2, [["render", Po2], ["__scopeId", "data-v-730ef6cd"]]);
var To2 = {
  install: (e2) => {
    e2.component(oe2.name, oe2), e2.component("Vue3" + oe2.name, oe2);
  }
};
export {
  oe2 as ColorPicker,
  To2 as default
};
/*! Bundled license information:

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=vue3-colorpicker.js.map
